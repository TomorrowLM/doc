# html

## SEO

- 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可
- 语义化的`HTML`代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不会执行js获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

## 标签

文本加粗标签   <strong></strong> <b></b>> 工作里尽量使用strong

文本倾斜标签	<em></em>> 	<i></i>>	工作里尽量使用em

删除线标签	<del></del>>	<s></s>>	工作里尽量使用del

下划线标签	<ins></ins>>	<u></u>	  工作里尽量使用ins

 <sup>上标</sup>  <sub>下标</sub>

超链接a:属性target,'_self'在自身页面打开，'_blank'打开一个新页面

 <base target="_blank">  让所有的超链接都在新窗口打开

锚链接：<p id="sd"></p>	<a href="#sd">回到顶部</a>

关键字：<mate name="keyword" content="">

网页描述:<mate name="description" content="">

网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com">

设置icon图标：<link rel="icon" href="xxx.ico">

img:`title`当鼠标滑动到元素上的时候显示,`alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片


## 表格

    <table>
        <caption>23</caption>
        <thead>
            <th>1</th>
            <th>2</th>
            <th></th>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>1</td>
                <td>1</td>
            </tr>
        </tbody>
    </table>

cellspacing：表示各单元格之间的空隙

cellpadding：表示单元格内容与单元格边界之间的距离

border-collapse:collapse;边框合并  

colspan=”2” 合并同一行上的单元格

rowspan=”2” 合并同一列上的单元格

```
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }
HTML Table是指使用原生的<table>标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。
display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。
```

## 表单

<fieldset></fieldset>  对表单信息分组

<legend>分组</legend>   表单信息分组名称

<optgroup label=""></optgroup>  对下拉列表select进行分组。Label=”” 分组名称。

```
  <fieldset>

​    <legend>信息分组名称</legend>

​    <select name="" id="">

​      <optgroup label="1">

​        <option value="1">1</option>

​        <option value="1">1</option>

​      </optgroup>

​    </select>

  </fieldset>
```

**表单元素属性**

- value 用于大部分表单元素的内容获取(option除外)
- type 可以获取input标签的类型(输入框或复选框等)
- disabled 禁用属性
- checked 复选框选中属性
- selected 下拉菜单选中属性

## tips

**标签语义化**：尽可能少的使用无语义的标签div和span；

**Charset  编码**：

Ascll	Ansi	Unicode  Gbk 	Gb2312	Big5	Utf-8  通用字符集

# html5

```html
<!-- 数据列表 -->
<input type="text" list="input_list">
  <datalist id="input_list">
    <option value="laoma"></option>
    <option value="lisi"></option>
</datalist>
  
<!--点击展示详细信息-->
<details>
    <summary>HTML 5</summary>
    <h1>This slide deck teaches you everything you need to know about HTML 5.</h1>
</details>

<!--小窗口-->
<iframe src="https://www.baidu.com" frameborder="0"></iframe>

<!--进度条-->
<progress>working...</progress>
<meter min="0" max="100" low="40" high="90" optimum="100" value="91">A+</meter>
```

```html
<form action="#" method="">
    <input type="text">
    <input type="image" src="toy.png">
    <input type="submit">
    <!-- file text password radio checkbox button image submit reset select button -->
    <input type="date">
    <input type="color">
    <input type="range" min="0" max="10" step="1" value="2">
    <hr>
    <input type="text" required>
    <input type="email" value="some@email.com">
    <input type="date" min="2010-08-14" max="2011-08-14" value="2010-08-14">
    <input type="range" min="0" max="50" value="10">
    <input type="search" results="10" placeholder="Search...">
    <input type="tel" placeholder="(555) 555-5555" pattern="^\(?\d{3}\)?[-\s]\d{3}[-\s]\d{4}.*?$">
    <input type="color" placeholder="e.g. #bbbbbb">
    <input type="number" step="1" min="-5" max="10" value="0">
  </form>
```



# css

## class命名规范

https://www.cnblogs.com/yyzyou/p/7920023.html

### 整体结构

头：header

页面主体：main

内容：content/container

侧栏：sidebar

栏目：column

页面外围控制整体布局宽度：wrapper

方向：left right center top bottom

内部： in

尾：footer

版权：copyright

### 菜单和导航

导航：nav

　　主导航：mainbav

　　子导航：subnav

　　顶导航：topnav

　　边导航：sidebar

　　左导航：leftsidebar

　　右导航：rightsidebar

菜单：menu

　　子菜单：submenu

​	   下拉菜单:dropmenv

标签页：tab

### title

| 文章列表：list  | 提示信息：msg | 小技巧：tips |
| --------------- | :-----------: | ------------ |
| 栏目标题：title |  字体：font   | 注释：note   |
| 文本：text      | 摘要: summary |              |
|                 |               |              |

### 动词

| 加入：joinus   | 指南：guild | 服务：service |
| -------------- | ----------- | ------------- |
| 注册：regsiter | 投票：vote  | 滚动：scroll  |
| 下载：download |             |               |
|                |             |               |

### 形容词

| 当前的: current |      |      |
| --------------- | ---- | ---- |
|                 |      |      |
|                 |      |      |
|                 |      |      |

### 功能

|   登录条：loginbar   |    广告：banner    |   功能区：shop    |
| :------------------: | :----------------: | :---------------: |
|      按钮：btn       |     图标: icon     |     线：line      |
|      热点：hot       |     新闻：news     | 合作伙伴：partner |
| 友情链接：friendlink |  版权：copyright   |    标签:label     |
|      图片：pic       |   首页：homepage   |    模态：modal    |
|      名片：card      | 通知：notification |  平台：platform   |
|    优惠券：coupon    |                    |                   |

样式文件命名
　　主要的:master.css
　　布局版面:layout.css
　　专栏:columns.css
　　文字:font.css
　　打印样式:print.css
　　主题:themes.css

## 行内元素和块元素

https://blog.csdn.net/Jwhahaha/article/details/102483938

### 块级元素

可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：

- 每个块级元素都是独自占一行。 
- 元素的高度、宽度、行高和边距都是可以设置的。　　 
- 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,**高度由内容撑开**

```
h1~h6:标题标签，用于标记网页中的大标题，依次从大到小
p：用于标记网页中的段落性文字，默认占满横向区域
div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽
section：区段，是用来定义文档的某个区域，章节
nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。
header：标签定义文档的页眉
footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等
pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。
address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行
audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。
/ 表格标签 /
table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸
thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加
tbody：表主体，一般省略不写，浏览器在解析时会自动添加
tr：表示一行
th：表头中的第一个单元格
td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列
/ 有序列表，无序列表 /
ul：无序列表
ol：有序列表
li：列表项
dl：定义列表，用于描述类表中的项目（dt（dd））
```

### **行内元素 inline**

行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： 

- 每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 
- 行内元素的高度、宽度、行高不可设置。 
- 元素的宽度就是它包含的文字或图片的宽度，不可改变。

- **行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以**

常见行内元素有以下：

```
span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化

a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件
有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址
strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容

b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调
s：删除线，仅仅是删除的效果
del：具有删除语义，delete删除
em：强调文本，斜体展示
sup：上标
sub：下标
```

### **行内块级元素 inline-block**

行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：

- 和其他行内或行内块级元素元素放置在同一行上；
- 元素的高度、宽度、行高以及顶和底边距都可设置。

```
img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示
button：按钮
input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。

单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值
type="checkbox"复选框

label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态
select:下拉列表
option:下拉选项
```

## float和position

### float

- 设置元素浮动后，对应的元素会脱离文档流，该元素的 `display` 值自动变成 `block`

- float 可以用来让文字环绕图片而已。

- float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。

- 假如某个div元素A是浮动的，如果A元素**上一个元素也是浮动的**，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素**上一个元素是标准流中的元素**，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。https://blog.csdn.net/qq_36595013/article/details/81810219

  <img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。

  <img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。

- **清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。**

  ```
  clear :none| left |right  | both
  none :允许两边都可以有浮动对象
  both :不允许有浮动对象
  left :不允许左边有浮动对象
  ```

- 作用

  ```css
  1.CSS浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。
  （1）父元素使用overflow:hidden来清除浮动，最好加上zoom:1;
  （2）父级div定义height
  （3）在父元素后面使用伪类：after和zoom
  .box:after{
  display:block;
  content:"";
  height:0;
  clear:both;
  }
  （2）结尾处加空div标签clear:both
  （2）对父元素设置display:table；使父元素形成BFC（块格式化上下文）
  			BFC三个特性:防止上下margin重叠，防止浮动元素重叠，防止浮动塌陷
  
  2.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷。
  给父级元素添加overflow:hidden
  ```

### position

- **position:absolute**
  - 会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。
  - **Z-index 仅能在定位元素上奏效（例如 position:absolute;）！** 
  - 脱离文档流

- **position:relative**

  - 相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化

    ```css
    background-color: green;
        position: relative;
        top: 50px;
        left: 100px;
    ```

    ![img](https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)



- **Position:fixed**
  - 固定定位之后，不占据原来的位置（脱标）
  - 元素使用固定定位之后，会转化为行内块


不同点：position相应的块级元素会覆盖下面的内容（文字），而float只会覆盖块级元素，里面的文字会脱离

## BFC

BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响

**触发条件 (以下任意一条)**

- `float`的值不为`none`
- `overflow`的值不为`visible`
- `display`的值为`table-cell`、`tabble-caption`和`inline-block`之一
- `position`的值为`absolute`或者`fixed`

> 在`IE`下, `Layout`,可通过`zoom:1` 触发

**.BFC布局与普通文档流布局区别 普通文档流布局:**

- 浮动的元素是不会被父级计算高度
- 非浮动元素会覆盖浮动元素的位置
- `margin`会传递给父级元素
- 两个相邻元素上下的`margin`会重叠

**BFC布局规则:**

- 浮动的元素会被父级计算高度(父级元素触发了`BFC`)
- 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了`BFC`)
- `margin`不会传递给父级(父级触发`BFC`)
- 属于同一个`BFC`的两个相邻元素上下`margin`会重叠

**开发中的应用**

- 阻止`margin`重叠
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 `div`都位于同一个 `BFC` 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

## 字体

- **font-variant :** **normal** | **small-caps**  设置字母字体 

  **normal :** 正常的字体 	**small-caps :** 小型的大写字母字体 这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。

- **text-transform :** **none** | **capitalize**  | **uppercase** | **lowercase** 

  **capitalize :** 　将每个单词的第一个字母转换成大写，其余无转换发生
  **uppercase :**  转换成大写
  **lowercase :** 　转换成小写

- **text-decoration:** none  |   underline   |     line-through



- **line-height :** **normal** | *length*  | inherit  	行高 **行高是指文本行基线间的垂直距离** 

  https://blog.csdn.net/a2013126370/article/details/82786681

  *length :* 　百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小

![img](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	line-height=font-size+行间距

​	height=line-height相等元素垂直居中

- 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的
- 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容
- 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中



- **vertical-align :** **baseline** |**sub**  | **super** |**top** |**text-top** |**middle** |**bottom**  |**text-bottom** |*length* 

-  该属性定义**行内块元素 表格单元格元素 **的基线相对父元素的基线的垂直对齐。允许指定负长度值和百分比值。 

  生效条件：

  - 子元素中的（inline-block/inline元素，eg:image）vertical-align才能起作用。
  - vertical-align不可继承，必须对子元素单独设置。



- **text-indent :** *length* 检索或设置对象中的文本的缩进。

- **letter-spacing :** **normal** | *length* （length允许为负值,px）检索或设置对象中的文字之间的间隔。

- **text-size-adjust**：auto | none | percentage 检索或设置移动端页面中对象文本的大小调整。

  auto：文本大小根据设备尺寸进行调整。

  none：文本大小不会根据设备尺寸进行调整。

  percentage用百分比来指定文本大小在设备尺寸不同的情况下如何调整。

- **direction**: rtl把文本方向设置为“从右向左”；
  ltr 	默认。文本方向从左到右。
  rtl 	文本方向从右到左。
  inherit 	规定应该从父元素继承 direction 属性的值。
  - **word-wrap**   **white-space**

  ```css
  word-wrap:
  normal	只在允许的断字点换行（浏览器保持默认处理）。
  break-word 允许长单词换行到下一行 
  break-word表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。
  //这个属性最初是由微软发明的,但W3C决定要用overflow-wrap替换word-wrap
  overflow-wrap 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。
  
  white-space:设置如何处理元素中的 空白。
  normal    连续的空白符会被合并，换行符会被当作空白符来处理。
  nowrap    和normal一样，连续的空白符会被合并。但文本内的换行无效。直到遇到 <br> 标签为止。
  pre       连续的空白符会被保留。在遇到换行符或者<br>元素时才会换行。
  pre-wrap  连续的空白符会被保留。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时才会换行(溢出了盒子)。
  pre-line  连续的空白符会被合并。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时会换行。
  ```

  

- **text-overflow :** **clip** | **ellipsis** 

  **clip :** 　不显示省略标记（...），而是简单的裁切 
  **ellipsis :** 　当对象内文本溢出时显示省略标记（...）  

- 文本缩略

  ```css
  section:nth-of-type(4)  p{
  			width: 200px;
  			border: 1px solid #ccc;
  			/*强制不换行 只在一行缩略  white-space: nowrap;*/
  			overflow: hidden;防止文本溢出
  			text-overflow: ellipsis;产生.....的效果
  			display:-webkit-box;
  			/*-webkit-line-clamp:n;第n行缩略*/
  			-webkit-line-clamp:2;
  			-webkit-box-orient:vertical;
  }
  ```

  

## 连写

font: font-style font-weight font-size/line-height font-family;

文本属性连写文字大小和字体为必写项。



border:color  style(solid实线dotted 点线dashed 虚线)   width

没有顺序要求，线型为必写项。

Padding: 20px;  上右下左内边距都是20px

Padding: 20px 30px;  上下20px  左右30px

Padding: 20px 30px 40px;  上内边距为20px 左右内边距为30px  下内边距为40

Padding: 20px 30px  40px 50px;  上20px 右30px 下40px 左 50px

## 裁剪图像

**clip :** **auto** | **rect (** *number  number number number* **)**依据上-右-下-左的顺序剪切图像。必须将[position](c_position.html)的值设为absolute，此属性方可使用。

clip-path  裁切一个圆角 inset(<top> <right> <bottom> <left> round <top-radius> <right-radius><bottom-radius> <left-radius>) 

## 布局

### 元素的水平居中

- 元素为行内元素，设置父元素`text-align:center`

- 如果子元素宽度固定，可以设置左右`margin`为`auto`;

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              top: 0;
              left: 50%;
              transform: translate( -50%,0);
          }
  ```

- 使用`flex-box`布局，指定`justify-content`属性为center

- ```
  display:block;
  margin:auto;
  ```

  

### 元素的垂直居中

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`

- 使用`flex`布局，设置为`align-item：center`

- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              left: 0;
              top: 50%;
              transform: translate( 0，-50%);
          }
  ```

- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值

- 文本垂直居中设置`line-height`为`height`值


### 实现已知或者未知宽度的垂直水平居中

```css
/** 1 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    margin: -50px 0 0 -50px;
  }
}

/** 2 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}

/** 3 **/
.wraper {
  .box {
    display: flex;
    justify-content:center;
    align-items: center;
    height: 100px;
  }
}

/** 4 **/
.wraper {
  display: table;
  .box {
    display: table-cell;
    vertical-align: middle;
  }
}
```

**如何垂直居中一个`<img>`**

```
#container     /**<img>的容器设置如下**/
{
    display:table-cell;
    text-align:center;
    vertical-align:middle;
}
```



## 选择器

### 优先级

1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。

2. 作为style属性写在元素内的样式 优先级1000

3. id选择器                                        优先级100

4. 类选择器和伪类和属性 				优先级10

5. 标签选择器和伪元素                     优先级1

6. 通配符选择器                                优先级0

7. 浏览器自定义或继承                    没有优先级

   **总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

 1.如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式

 2.交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较

 3.并集的话 就是各算各的。

### 属性选择器

```css
/* 存在title属性的<a> 元素 */
a[title]
/* 存在href属性并且属性值匹配"https://example.org"的<a> 元素 */
a[href="https://example.org"]
/* 存在href属性并且属性值包含"example"的<a> 元素 */
a[href*="example"]
/* 存在href属性并且属性值结尾是".org"的<a> 元素 */
a[href$=".org"] 
/* 存在class属性并且属性值包含以空格分隔的"logo"的<a>元素 */
a[class~="logo"]
```

### 组合选择器

相邻兄弟选择器 A + B
普通兄弟选择器 A ~ B
子选择器 A > B
后代选择器 A B

交集 
A.B{
} 
并集 
A, B｛
｝ 

### 伪类选择器

```
a:link{属性:值;}       链接默认状态	 
a:visited{属性:值;}     链接访问之后的状态 
a:hover{属性:值;}      鼠标放到链接上显示的状态  	a:active{属性:值;}      链接激活的状态
a:focus{属性:值；}     获取焦点
```

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `p:nth-of-type(n)` 选择E的父元素下的第n个E元素
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容。
- `:enabled` 已启用的表单元素。
- `:disabled` 已禁用的表单元素。
- `:checked` 单选框或复选框被选中。
- `:empty` 选中没有任何子节点的E元素；

### 伪元素选择器

```
伪元素特性
减少 dom 节点数,但不利于不利于 SEO
它不存在于文档中，所以 js 无法操作它
它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件
```

- E::selection 可改变选中文本的样式


- E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。


- E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。

  ```css
  块级元素才能有:before, :after，譬如 img 就不能设置，亦即某些元素是没有:before, :after 的
  伪类元素的display是默认值inline
  
  （1）各种图标
  利用这两个伪类，可以实现需要简单的图标
  （2）attr()
  通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。
  a::after{
      content:  attr(href) ;
  }
  element.setAttribute("data-age",age);
  element.dataset["age"]
  <a href="http://www.cnblogs.com/starof">starof</a>
  （3）引用媒体文件
  a::before{
      content: url("https://www.baidu.com/img/baidu_jgylogo3.gif");
  }
  （4）清除浮动
  .cf:before,
  .cf:after {
      content: " ";
      display: table; 
  }
  .cf:after {
      clear: both;
  }		
  ```

## tips

- Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数


- ```
  visibility:hidden; 隐藏元素  隐藏之后还占据原来的位置。
  opacity=0，该元素隐藏起来了，但不会改变页面布局,还占据原来的位置
  display:none;隐藏元素  隐藏之后不占据原来的位置。
  ```

  

  ```
  透明度
  background-color: rgba(0, 0, 0, 0.3);
  opacity: 0.3;
  transparent是颜色的一种，这种颜色叫透明色。
  ```

- placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）

  ```
  
  input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-moz-placeholder, textarea:-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input::-moz-placeholder, textarea::-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-ms-input-placeholder, textarea:-ms-input-placeholder {
      color: #666;
      font-size: 16px;
    }
  ```


# css3

### 盒模型

https://www.imooc.com/article/68238

<img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg" style="zoom:50%;" />

标准盒子模型

```
盒子实际内容（content）的width/height=我们设置的width/height;
盒子总宽度/高度=width/height+padding+border+margin。
```

IE盒子模型

```
content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)
盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin
```

**box-sizing 常用的属性有哪些？分别有什么作用**

- `box-sizing: content-box;` 默认的标准(W3C)盒模型元素效果
- `box-sizing: border-box;` 触发怪异(IE)盒模型元素的效果
- `box-sizing: inherit;` 继承父元素 `box-sizing` 属性的值

### 阴影

文本阴影：text-shadow 

color  length  lenth opacity  [ inset(阴影向内) ] 

颜色 水平偏移量  垂直偏移量  模糊度  （缩展量）

边框阴影 ：border-shadow

box-shadow：[inset(阴影向内)]  水平偏移量  垂直偏移量  模糊度  （缩展量）  颜色

### 边框圆角box-radius

 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（**顺时针方向**） 

 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。 

 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角 

 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;

**outline :**[ **outline-color** ](c_outlinecolor.html)||[**outline-style** ](c_outlinestyle.html)||[ **outline-width** ](c_outlinewidth.html)

设置或检索对象外的线条轮廓。outline画在[border](c_border.html)外面，并且不一定是矩形

### 边框图像：

```
border-image-source: url(images/border.png);
border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。
border-image-width: 10px;指定图像边界的宽度：
border-image-repeat: round/stretch/repeat;
```

### 盒模型：

box-sizing:border-box;使width包含内容，padding，和border

元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 		

content-box,width只包含内容

### 背景

**background:color url  repeat position  attachment**

设置背景颜色会填充content,padding。

连写的时候没有顺序要求，url为必写项  

- **background-position:left top**

- **background-attachment :** **scroll** | **fixed**  

  **scroll :** 　背景图像是随对象内容滚动
  **fixed :** 　背景图像固定 

- **background-clip**：padding-box/content-box/border-box;  修改背景颜色区域/规定背景的绘制区域。

- **background-origin:** border-box;修改背景图片所在区域

- **background-position:**center center;图片水平垂直居中

```
background-size
cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。
contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。

```

### 渐变

```
background-image：linear-gradient();radial-gradient()
repeating-linear-gradient   repeating-radial-gradient
```

### 伸缩布局

```
display: flex; 会浮动
justify-content: space-between;两端对齐布局（伸缩布局）
```

```
flex-direction: column;决定主轴的方向(即子元素的排列方向)
调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse
```

```
justify-content（水平方向）定义了子元素在主轴上的对齐方式
主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式  
```

```
align-items（垂直方向）定义子元素在侧轴上如何对齐
调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch
```

```
 flex-wrap 
 控制是否换行，包括wrap、nowrap （不换行）
```

```
align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用
可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch 
```

```
flex 
控制子元素伸缩比例 
```

```
align-self 侧轴上单个项目对齐方式
单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch 
```

```
flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
```

order **定义子元素的排列顺序, 数值越小 排列越靠前 默认为0** 

### 多列布局

```
/*设置分成几列*/-webkit-column-count: 4;
/*当列宽*列数乘积大于盒子总宽，会自动调整列数*/
-webkit-column-width: 400px;
/*调整列之间的宽度*/
-webkit-column-gap: 60px;
-webkit-column-rule: 2px dashed #CCC;

//标题单独置一列
/*all代表所有列*/
-webkit-column-span: all;
```



```
设置分成几列-webkit-column-count: 3;
当列宽*列数乘积大于盒子总宽，会自动调整列数-webkit-column-width: 200px;
调整列之间的宽度-webkit-column-gap: 60px;
-webkit-column-rule: 2px dotted #CCC;分割线设置
```

### 响应式

#### 单位

https://blog.csdn.net/liwusen/article/details/80834546

https://www.cnblogs.com/chenyoumei/p/10510321.html

- 像素

  像素是网页布局的基础，**一个像素表示了计算机屏幕所能显示的最小区域**，像素分为两种类型：**css像素和物理像素**。

  我们在js或者css代码中使用的px单位就是指的是css像素，物理像素也称设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，**设备的密度越高，物理像素也就越多**。

  像素比(DRP)，表示一个CSS像素占用几个物理像素
  
  ```
  1 CSS像素 = 物理像素／分辨率
  ```
  
  ```
  //有一个750px * 1134px的视觉稿
  //pc端的布局视口通常情况下为980px
  PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px
  //移动端以iphone6为例，分辨率为375 * 667
  iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px
  //在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。
  ```

- rem相对于根元素html的font-size值的大小，此单位若要用于屏幕自适应，可与vw配合使用设置根元素的字体大小。375px的网页的设计稿。此时，1vw=3.75px；4vw=15px；8vw=30px；

- 百分比%，一般不用%，因为不确定盒子的设置


1. 子元素**width**或**height**的百分比是**父元素width或height的百分比**
2. **top**、**bottom**的百分比是相对于(默认定位)**父元素的height**
3. **left**、**right**的百分比是相对于(默认定位)**父元素的width**
4. **padding**、**margin**不论是垂直方向或者是水平方向，都相对于直接**父元素的width**
5. **border-radius**、**translate**、**background-size**的百分比，则是相对于**自身的width**

#### 自适应

- 查看设计图，需要尽可能的添加多的div来包含元素

- 外层盒子使用flex进行布局，不设置绝对宽度px(使用rem或者%布局)，高度由里面的内容撑开（**撑不开就用margin、padding**）。内层盒子使用rem布局。
- float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。


- 图片的自适应（fluid image）

  ```
  img { width: auto; max-width: 100%; }
  ```

- 自适应

  - yd ui 移动端

    https://blog.csdn.net/weixin_44823323/article/details/99640765

    https://www.jianshu.com/p/b00cd3506782

    ```css
    (function (doc, win) {
            var docEl = doc.documentElement,
                resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
                recalc = function () {
                    var clientWidth = docEl.clientWidth;
                    if (!clientWidth) return;
                    if(clientWidth>=640){
                        docEl.style.fontSize = '100px';
                    }else{
                        docEl.style.fontSize = 100 * (clientWidth / 640) + 'px';
                    }
                };
    
            if (!doc.addEventListener) return;
            win.addEventListener(resizeEvt, recalc, false);
            doc.addEventListener('DOMContentLoaded', recalc, false);
        })(document, window);
    ```

  - 媒体查询



### 动画

http://www.animate.net.cn/1853.html

animate.css动画框架

**过渡：**

transition:

property – 什么属性将用动画表现，例如, opacity。

duration –  过渡的时间 

transition-delay – 设置过渡延时

timing-function  – 过渡的速度;

匀速linear  逐渐降速ease 加速ease-in 降速ease-out  先加速后减速ease-in-out

```
transform 和 transition 属性实现简单旋转效果的例子：

<div style="transition: transform 3s ease-in" 
  onclick="this.style.transform='rotate(360deg)'">
点击这个方块，能让它旋转起来。
</div>
```

**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       **

动画相比过渡可以控制更多细节，可以将一个动画拆成多个步骤

animation: change 5s infinite;

@keyframes change {0%{}	25%{}	100%{}}

​			动画名称

/*	animation-duration: 1s;
			动画结束后的状态
/*			animation-fill-mode: forwards;
			无限次播放
/*			animation-iteration-count: infinite;
			动画延时
/*			animation-delay: 1s;
			动画暂停
/*			animation-play-state: paused;
			动画反方向
/*			animation-direction: alternate;
			动画速度
/*			animation-timing-function: linear;

### 转化

transform-origin: left bottom;旋转的定位点

transform: rotate(360deg);旋转   

rotate：2D平面旋转顺时针旋转指定的角度。	

3D: transform-style: preserve-3d;	 transform: rotateY/X(0deg);

transform:scale(1.5);盒子扩大1.5倍

```
如何实现小于12px的字体效果
transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;

transform: scale(0.7);
```

缩放 scale(x, y) 可以对元素进行水平和垂直方向的缩放  

transform: skew(45deg);倾斜              

transform: translate(400px) 向左移动400px	translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%

### 视距

perspective: 500px;	近大远小	元素定义perspective属性，其子元素会获得透视效果（透视效果是写在父亲身上），而不是元素本身。只有3D才有

perspective-origin 灭点/消失点

### 媒体查询

```
@media screen and (max-width:600px) {   
body {      background-color: blue;   }}
@media screen and (min-width:900px) {  
body {      background-color: red;   }}

```

# sass

**css预处理器sass**

## 变量

```
　　$blue : #1875e7;　

　　div {
　　　color : $blue;
　　}
```

如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。

```
　$side : left;

　　.rounded {
　　　　border-#{$side}-radius: 5px;
　　}
```

## **计算功能**

SASS允许在代码中使用算式：

```
　　body {
　　　　margin: (14px/2);
　　　　top: 50px + 100px;
　　　　right: $var * 10%;
　　}
```

## **嵌套**

SASS允许选择器嵌套。比如，下面的CSS代码：

```
div h1 {
　　　　color : red;
}
```

可以写成：

```
　　div {
　　　　hi {
　　　　　　color:red;
　　　　}
　　}
```

属性也可以嵌套，比如border-color属性，可以写成：

```
　　p {
　　　　border: {
　　　　　　color: red;
　　　　}
　　}
```

在嵌套的代码块内，可以**使用&引用父元素**。比如a:hover伪类，可以写成：

```
　　a {
　　　　&:hover { color: #ffb3ff; }
　　}
```

**注释**

SASS共有两种注释风格。

标准的CSS注释 /* comment */ ，会保留到编译后的文件。

单行注释 // comment，只保留在SASS源文件中，编译后被省略。

在/*后面加一个感叹号，表示这是"重要注释"。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。

```
/*!
　　　　重要注释！
*/
```

## **代码的重用**

### **继承**

SASS允许一个选择器，继承另一个选择器。比如，现有class1：

```
　　.class1 {
　　　　border: 1px solid #ddd;
　　}
```

class2要继承class1，就要使用@extend命令：

```
　　.class2 {
　　　　@extend .class1;
　　　　font-size:120%;
　　}
```

### **Mixin**

Mixin有点像C语言的宏（macro），是可以重用的代码块。

使用@mixin命令，定义一个代码块。

```
@mixin left {
　　　　float: left;
　　　　margin-left: 10px;
　　}
```

使用@include命令，调用这个mixin。

```
div {
　　　　@include left;
　　}
```

mixin的强大之处，在于可以指定参数和缺省值。

```
　　@mixin left($value: 10px) {
　　　　float: left;
　　　　margin-right: $value;
　　}
```

使用的时候，根据需要加入参数：

```
　　div {
　　　　@include left(20px);
　　}
```

# js

## 通识

```
变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头
驼峰命名法。首字母小写，后面单词的首字母需要大写
```

**数值判断**

- NaN：not a number 该属性用于指示某个值不是数字。 

  - NaN 与任何值都不相等，包括他本身

- isNaN: is not a number判断是否是数字，若是数字返回false

- isFinite(number ) 函数用于检查其参数是否是无穷大。

  **提示：** 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。

```
undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined
null表示一个空，变量的值如果想为null，必须手动设置
```

```
布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象
				转换成false  空字符串  0  false  null  undefined
```

转换成字符串类型：

- toString() String() 拼接字符串方式

**转换成数值类型：**

- 1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 

- 2.parseInt() 

- 3.parseFloat()

**堆栈**

**栈：**

- 存储基础数据类型

- 栈会开辟一个内存

- 按值访问

- 存储的值大小固定

- 由系统自动分配内存空间

- 空间小，运行效率高

- 先进后出，后进先出

- 栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。

- 微任务和宏任务

  **栈先进后出，队列先进先出**

**堆:**

- 存储引用数据类型
- 堆共用同一个内存
- 按引用访问
- 存储的值大小不定，可动态调整
- 主要用来存放对象
- 空间大，但是运行效率相对较低
- 无序存储，可根据引用直接获取


## 位置

### 获取鼠标当前位置（事件对象）

- offsetX、offsetY：  鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。内填充边意思是不包含border，但包含padding，类似于padding-box。

- clientX、clientY： 鼠标当前位置 相对于 **视口**顶部、浏览器可视区域左部 的位置；

- pageY、pageX：     鼠标当前位置 相对于 **页面/文档**顶部、**页面/文档**左部的位置；

- screenY、screenX：鼠标当前位置 相对于 **屏幕**顶部、屏幕左部的位置；

  **他们均是鼠标事件的一级属性 ，如e.clientY**

![图片描述](https://segmentfault.com/img/bVXWPA?w=1043&h=552)



![img](https://upload-images.jianshu.io/upload_images/1811036-510a2fbcd5bb2d17.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)



Element.getBoundingClientRect()   获取元素相对于**视口**的位置 

top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。

![img](https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp)

`window.scrollTo(options)`方法,`options`是一个对象，有三个属性：
`top` 等同于 y-coord
`left` 等同于 x-coord
`behavior` 类型String,表示滚动行为,支持参数 `smooth`(平滑滚动),`instant`(瞬间滚动),默认值auto（等同于`instant`）

### 获取元素当前位置

clientHeight：内容+padding（上下）

clientWidth：内容+padding（左右）

offsetTop：从边框border（不包含）距离父元素的高度距离

offsetLeft：从边框border（不包含）距离父元素的宽度距离

offsetHeight：内容+padding+border

offset Width：内容+padding+border

scrollleft/top 滚动出去的距离 scrollwidth/height 总的宽/高（显示和隐藏的）

## 获取

### 属性获取

- js获取css属性值

  - jquery方法

  ```
  //jquery方法
  const jq_width = $('.box').css('width');
  const jq_lineHeight = $('.box').css('line-height');
  console.log(jq_width,jq_lineHeight);//200px 150px
  ```

  - 然后我们再用js原生方法去获取

  ```js
  // 原生style.css方法
  const box = document.querySelector('.box');
  const js_width = box.style.width;
  const js_lineHeight = box.style.lineHeight;
  console.log(js_width,js_lineHeight);//   50px
  //在这里我们会发现style.css方法只能获取到写在标签上的属性 style = "line-height:150px" 不能获取写在<style>``</style>中的css属性
  ```

  - 使用`window.getComputedStyle`这个方法获取所有经过浏览器计算过的样式

- elementNode.getAttribute(name)：方法通过名称获取属性的值。

  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。

  elementNode.removeAttribute(name)：方法通过名称删除属性的值。


### 节点元素获取

getElementsBy方法都是伪数组arguments

判断当前的子节点是否是元素节点	if (node.nodeType === 1)

parentNode	父元素		childNodes  所有子节点	children    所有的子元素

lastChild    获取最后一个子节点	lastElementChild     获取最后一个子元素

nextSibling  下一个兄弟节点		nextElementSibling	下一个兄弟元素

previousSibling   上一个兄弟节点	 previousElementSibling    上一个兄弟元素

## 字符串

**不会改变原来的字符串**

```js
// 1 字符方法
charAt(index)    	//获取指定位置处字符 myString.charAt(1)
charCodeAt()  	//获取指定位置处字符的ASCII码
// 2 字符串操作方法
concat()   		//拼接字符串，等效于+，+更常用
slice(startIndex,endIndex)
//从start位置开始，截取到end位置，end取不到
//如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。
//如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。
substring(startIndex,endIndex) 	
//从start位置开始，截取到end位置， end取不到
//若startIndex或者endIndex为负，则会被替换为0。
substr(fromIndex,length)   		
//从start位置开始，截取length个字符
//若起始索引为负，则从右往左开始截取
// 3 位置方法
indexOf('' '',[index] )   	//返回指定内容在元字符串中的位置，只找第一个匹配的,若没有则返回-1是，indexOf('a',2);从位置2开始找到a的位置
lastIndexOf() 	//从后往前找，只找第一个匹配的
// 4 去除空白   
trim()  		//只能去除字符串前后的空白，字符之间的空格不能去掉
// 5 大小写转换方法
to(Locale)UpperCase() 	//转换大写
to(Locale)LowerCase() 	//转换小写
//6 split()字符转换为数组 split()还可以结合正则表达式
var str='a,b,c,d';
var arr=str.split(',');//以逗号为分割成数组
arr.join('');
```

## 数组

### 会改变原来数组的有：

#### pop()

删除数组的最后一个元素并返回删除的元素。

#### push()

向数组的末尾添加一个或更多元素，并返回新的长度。

#### shift()

删除并返回数组的第一个元素。

#### unshift()

向数组的开头添加一个或更多元素，并返回新的长度。reverse()---反转数组的元素顺序。

#### reverse()	

翻转数组

#### sort() 	

*arr.sort([comparefn])*

- comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序

- 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：
  - 若 comparefn(a, b) < 0，那么a 将排到 b 前面；
  - 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；
  - 若 comparefn(a, b) > 0，那么a , b 将调换位置；

```js
//即使是数组sort也是根据字符，从小到大排序
//采用冒泡排序
sort(fn(a,b){
// 升序
return a - b;
// 倒序
return b - a;
})
fn（a,b）{return <0||>0},返回小于0升序，大于0降序。

```

```
var a = [2,3,1,0].sort(function(a,b){
    console.log(a,b)
    return a-b
})
:3 2
:1 3 
:1 2 
:0 2
:0 1
```

**sort()方法的比较逻辑为：**
前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序

#### splice()

用于插入、删除或替换数组的元素。

```js
arr.splice(start,deleteCount[, item1[, item2[, …]]])

var array = ["one", "two", "four"];
// splice(position, numberOfItemsToRemove, item)
// 拼接函数(索引位置, 要删除元素的数量, 元素)
array.splice(2, 0, "three"); // 
array; //["one", "two", "three", "four"]

var array = ["apple","boy"];
var splices = array.splice(1,1);
console.log(array); // ["apple"]
console.log(splices); // ["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素
```

数组指定位置插入元素

```
Array.prototype.insert = function (index, item) {
this.splice(index, 0, item);
};
var nums = ["one", "two", "four"];
nums.insert(2, 'three'); // 注意数组索引, [0,1,2..]
array // ["one", "two", "three", "four"]
```



### 不会改变原来数组的有：

#### concat() 

将传入的数组或者元素与原数组合并，组成一个新的数组并返回。

语法：***arr.concat(value1, value2, …, valueN)***

```
var array = [1, 2, 3];
var array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改
```

若concat方法中不传入参数，那么将基于原数组**浅复制**生成一个一模一样的新数组（指向新的地址空间）。

```js
var array = [{a: 1}];
var array3 = array.concat();
console.log(array3); // [{a: 1}]
console.log(array3 === array); // false
console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用
```

#### join() 

将数组中的所有元素连接成一个字符串。

语法：*arr.join([separator = ‘,’])* separator可选，缺省默认为逗号。

```
var array = ['We', 'are', 'Chinese'];
console.log(array.join()); // "We,are,Chinese"
console.log(array.join('+')); // "We+are+Chinese"
console.log(array.join('')); // "WeareChinese"
```

#### slice() 

将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。

语法：*arr.slice([start[, end]])*

参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。

如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。

slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。

```
var array = ["one", "two", "three","four", "five"];
console.log(array.slice()); // ["one", "two", "three","four", "five"]
console.log(array.slice(2,3)); // ["three"]
123
```

**浅复制** 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。

```
var array = [{color:"yellow"}, 2, 3];
var array2 = array.slice(0,1);
console.log(array2); // [{color:"yellow"}]
array[0]["color"] = "blue";
console.log(array2); // [{color:"bule"}]
12345
```

由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。

#### toString()

#### toLocaleString()

#### indexOf

indexOf(arr[i],[index] )   	//从位置index查找arr[i]在数组中的位置，只找第一个匹配的,若没有则返回-1

#### lastindexOf

## 遍历

### 数组

**迭代方法 不会修改原数组**

every()、filter()、forEach()、map()、some()

#### forEach()

指定数组的每项元素都执行一次传入的函数，返回值为undefined。

语法：**arr.forEach(fn, thisArg)**

fn 表示在数组每一项上执行的函数，接受三个参数：

- value 当前正在被处理的元素的值
- index 当前元素的数组索引
- array 数组本身

thisArg 可选，用来当做fn函数内的this对象。

```js
var array = [1, 3, 5];
var obj = {name:'cc'};
var sReturn = array.forEach(function(value, index, array){
  array[index] = value * value;
  console.log(this.name); // cc被打印了三次
},obj);
console.log(array); // [1, 9, 25], 可见原数组改变了
console.log(sReturn); // undefined, 可见返回值为undefined
```

#### map()

使用传入函数处理每个元素，并返回函数的返回值组成的新数组。

语法：**arr.map(fn, thisArg)**

参数介绍同 forEach 方法的参数介绍。

#### every()

数组的每一项执行的函数都满足条件就返回true

#### some()

对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

#### filter()

执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素

语法：**arr.filter(fn, thisArg)**

```
var array = [18, 9, 10, 35, 80];
var array2 = array.filter(function(value, index, array){
  return value > 20;
});
console.log(array2); // [35, 80]
```

#### reduce()

reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。

语法：**arr.reduce(fn, initialValue)**

fn 表示在数组每一项上执行的函数，接受四个参数：

- previousValue 上一次调用回调返回的值，或者是提供的初始值
- value 数组中当前被处理元素的值
- index 当前元素在数组中的索引
- array 数组自身

initialValue 指定第一次调用 fn 的第一个参数。

#### entries() 

方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。

语法：**arr.entries()**

```
var array = ["a", "b", "c"];
var iterator = array.entries();
console.log(iterator.next()); //{ value: [ 0, 'a' ], done: false } 
console.log(iterator.next().value); // [0, "a"]
console.log(iterator.next().value); // [1, "b"]
console.log(iterator.next().value); // [2, "c"]
console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined
```

#### keys

keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）

语法：**arr.keys()**

```js
var array = ["abc", "xyz"];
var iterator = array.keys();
console.log(iterator.next()); // Object {value: 0, done: false}
console.log(iterator.next()); // Object {value: 1, done: false}
console.log(iterator.next()); // Object {value: undefined, done: false}
```

#### values()

values() 方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。

语法：**arr.values()**

遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。

```js
var array = ["abc", "xyz"];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz
```

#### for

 **for...in循环**

精准的迭代，可以迭代对象的元素。也可以迭代数组。

【注意】使用`for ... in`，迭代的是元素（keys），对于数组来说，则为下标（0,1,2...,length-1）

```text
for(var key in arr) {
    //执行相关操作
}
```

 **for...of循环（ES6支持）**

```text
for(let item of arr) {
    //执行相关操作
}
```

和`for...in`不同的是，`for...of`迭代出来的是值（value），对于数组来说，则是一个元素值。

### 对象

#### for...in 

**for...in遍历**

```js
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var el in book) {
    console.log(book[el]);
}
```

**for ... of遍历**

此方法，**不能遍历普通对象**(因为能够被for...of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口，使得它无法被for...of遍历。)，需要和`Object.keys()`搭配使用，先获取对象的所有key的数组 然后遍历：

```text
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var key of Object.keys(book)) {
    console.log(book[key]);
}
```

【注意】`Object.values()`返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。

同时，由于`Object.keys()`返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。

## Math

```js
Math.PI						// 圆周率
Math.random()				// 生成随机数
Math.floor()/Math.ceil()	 // 向下取整/向上取整
Math.round()				// 取整，四舍五入
Math.abs()					// 绝对值
Math.max()/Math.min()		 // 求最大和最小值                                                                                                           
Math.sin()Math.cos()		 // 正弦/余弦
Math.power()/Math.sqrt()	 // 求指数次幂/求平方根
```

## Date

### **new Date()**创建新的日期对象

1. 用整数初始化日期对象

   new Date(yyyy,mth,dd,hh,mm,ss); 
   new Date(yyyy,mth,dd); 

   注意：

   - 您不能省略月份。如果只提供一个参数，则将其视为毫秒。
   - 一位和两位数年份将被解释为 19xx 年：

   ```
   yyyy:四位数表示的年份
   mth:用整数表示月份，从（１月）0到１１（１２月）
   dd:表示一个 月中的第几天，从1到31
   hh:小时数，从0（午夜）到23（晚11点）
   mm: 分钟数，从0到59的整数
   ss:秒数，从0到59的整数
   ```

2. 用字符串初始化日期对象

   new Date("2017/06/06"); 

   new Date(“2017-08-08”); 

   new Date("month dd,yyyy hh:mm:ss");  

   new Date("month dd,yyyy");

3. 用毫秒时间戳初始化日期对象

   new Date(ms);

   ```
   JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。
   零时间是 1970 年 1 月 1 日 00:00:00 UTC。
   ```

   

### 获取日期方法

| 方法              | 描述                                 |
| :---------------- | :----------------------------------- |
| getDate()         | 以数值返回天（1-31）                 |
| getDay()          | 以数值获取周名（0-6）                |
| getFullYear()     | 获取四位的年（yyyy）                 |
| getHours()        | 获取小时（0-23）                     |
| getMilliseconds() | 获取毫秒（0-999）                    |
| getMinutes()      | 获取分（0-59）                       |
| getMonth()        | 获取月（0-11）                       |
| getSeconds()      | 获取秒（0-59）                       |
| getTime()         | 获取时间（从 1970 年 1 月 1 日至今） |

```
date.getFullYear()//获取完整的年份(4位,1970-????)
date.getMonth() //获取当前月份(0-11,0代表1月)
date.getDate()//获取几号   - 0 - 31 比如25
date.getDay()//获取星期几 - 比如星期3的3
date.getHours()//获取小时
date.getTime()// 获取相对于1970-01-01的毫秒值
```

### 日期设置方法

设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：

| 方法              | 描述                                         |
| :---------------- | :------------------------------------------- |
| setDate()         | 以数值（1-31）设置日                         |
| setFullYear()     | 设置年（可选月和日）                         |
| setHours()        | 设置小时（0-23）                             |
| setMilliseconds() | 设置毫秒（0-999）                            |
| setMinutes()      | 设置分（0-59）                               |
| setMonth()        | 设置月（0-11）                               |
| setSeconds()      | 设置秒（0-59）                               |
| setTime()         | 设置时间（从 1970 年 1 月 1 日至今的毫秒数） |

### **时间戳转化为日期的方式**

```
// Mon May 28 2018
console.log(newDate.toDateString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toGMTString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toISOString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toJSON());

// 2018/5/28
console.log(newDate.toLocaleDateString());
 
// 2018/5/28 下午11:24:12
console.log(newDate.toLocaleString());
 
// 下午11:24:12
console.log(newDate.toLocaleTimeString());
 
// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toString());
 
// 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toTimeString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toUTCString());
```

## 构造函数

### 背景

**（1）对象是单个实物的抽象。**

一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。

**（2）对象是一个容器，封装了属性（property）和方法（method）。**

属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为`animal`对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。



JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。

```js
function Person(name) {    
      this.name = name  
}  
var p1 = new Person('咚咚')  
console.log("p1:",p1);  
console.log("p1.__proto__ === Person.prototype:",p1.__proto__ === Person.prototype); console.log("Person.prototype:",Person.prototype);
```

![img](https://user-gold-cdn.xitu.io/2020/3/15/170dd61fa1c7f710?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**new 命令的原理**

使用`new`命令时，它后面的函数依次执行下面的步骤。

1. 创建一个空对象，作为将要返回的对象实例。
2. 将这个空对象的原型，指向构造函数的`prototype`属性。
3. 将这个空对象赋值给函数内部的`this`关键字。
4. 开始执行构造函数内部的代码。

### 原型链

<img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" />

所有对象都有自己的原型对象（prototype）。原型对象的所有属性和方法，都能被实例对象共享。

一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……

如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即`Object`构造函数的`prototype`属性。也就是说，所有对象都继承了`Object.prototype`的属性。这就是所有对象都有`valueOf`和`toString`方法的原因，因为这是从`Object.prototype`继承的。

<img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" />

那么，`Object.prototype`对象有没有它的原型呢？回答是`Object.prototype`的原型是`null`。`null`没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是`null`。

```js
Object.getPrototypeOf(Object.prototype)
// null
Object.prototype.__proto__ === null
```

#### constructor 

`prototype`对象有一个`constructor`属性，默认指向`prototype`对象所在的构造函数。

```js
function P() {}
P.prototype.constructor === P // true
```

由于`constructor`属性定义在`prototype`对象上面，意味着可以被所有实例对象继承。

```js
function P() {}
var p = new P();

p.constructor === P // true
p.constructor === P.prototype.constructor // true
p.hasOwnProperty('constructor') // false
```

上面代码中，`p`是构造函数`P`的实例对象，但是`p`自身没有`constructor`属性，该属性其实是读取原型链上面的`P.prototype.constructor`属性。

#### instanceof

判断是否是数组 /判断某个对象是否是某个构造函数的实例 

### 继承

https://blog.csdn.net/qq_42926373/article/details/83149347

#### 属性继承

不能继承父级的原型

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

function Student (name, age) {
  // 借用构造函数继承属性成员 
  Person.call(this, name, age)
}

var s1 = Student('张三', 18)
console.log(s1.type, s1.name, s1.age) // => human 张三 18
```

#### 原型方法继承

不能继承父级的构造函数

```js
Teacher.prototype = Object.create(Person.prototype)
Teacher.prototype.constructor = Teacher
```

**一旦我们修改构造函数的原型对象，为了防止引用出现问题，同时也要修改原型对象的constructor属性。**

#### 组合继承

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

Person.prototype.sayName = function () {
  console.log('hello ' + this.name)
}

function Student (name, age) {
  Person.call(this, name, age)
}

// 利用原型的特性实现继承
Student.prototype = new Person()
// 若不指明原型对象，会指向person
//console.log(Student.prototype.constructor);
Student.prototype.constructor = Student;
var s1 = Student('张三', 18)

console.log(s1.type) // => human

s1.sayName() // => hello 张三
```

## this指向

### 指向对象

https://www.cnblogs.com/dongcanliang/p/7054176.html

- 在全局作用域下 this对象指向的是window对象

- 在函数作用域下 

  - 在非严格模式下: this的指向依旧是window对象
  - 在严格模式下:this的指向是undefined

- 构造函数调用， 此时 this 指向 实例对象

- 在对象里面this的指向是当前该对象

  特殊情况

  - ```js
    var obj = {
        name(){
            console.log(this) //obj
           function fn(){
               console.log(this) //window
           }
           fn()
        }
    }
    obj.name()
    ```

    如何让函数里的那个函数fn也能使用当前obj这个对象了

    1. 将this赋值给that
    2. 使用箭头函数

  - ```js
    var o = {
      prop: 37,
      f: function() {
        return this.prop;
      }
    };
    console.log(o.f());  //37
    var a = o.f;
    console.log(a()):  //undefined
    ```

- 原型链中this,原型链中的方法的this仍然指向调用它的对象

  ```js
  var o = {
    f : function(){ 
      return this.a + this.b; 
    }
  };
  var p = Object.create(o);
  p.a = 1;
  p.b = 4;
  
  console.log(p.f()); // 5
  ```

  可以看出， 在p中没有属性f，当执行p.f()时，会查找p的原型链，找到 f 函数并执行，但这与函数内部this指向对象 p 没有任何关系，只需记住谁调用指向谁。

- 箭头函数不绑定this， 它会捕获其所在（即定义的位置）**上下文的this值**， 作为自己的this值

### call、apply、bind

```
1.1 作用
他们的作用都是改变函数内部的this。
这三个函数都是Function原型中的方法（所有的函数都是Function的实例），也就是说只有函数才可以直接调用这些方法。
1.2 三者区别
参数： 三个函数的第一个参数都是需要绑定的 this。
call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会调用
call/bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。
apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。 
    call 语法：  foo.call(this, arg1,arg2, ... ,argn );
    apply 语法： foo.apply(this, [ arg1,arg2, ... ,argn ] );
    bind 语法：  foo.bind(this, arg1,arg2, ... ,argn);
调用：
call,apply： 调用后立即执行原函数。
bind： 调用后返回已经绑定好this的函数。

处理伪数组 (最常用)，继承
```

## 事件流

### 阶段

> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段（`targetin`）、冒泡阶段（`bubbling`）

- 冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发
- 捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发
- `DOM`事件流：同时支持两种事件模型：捕获型事件和冒泡型事件
- 阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在IE下设置`cancelBubble = true`
- 阻止捕获：阻止事件的默认行为，例如`click - <a>`后的跳转。在`W3c`中，使用`preventDefault()`方法，在`IE`下设置`window.event.returnValue = false`

### 监听事件

```xml
.addEventListener('click', fn, false);//false(默认)是事件冒泡，true是事件捕获
```

```
e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。
```

```
在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。
```

### 事件对象event

- `target`是事件触发的真实元素
- `currentTarget`是事件绑定的元素
- 事件处理函数中的`this`指向是中为`currentTarget`。
- `currentTarget`和`target`，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）
  - 当事件是子元素触发时，`currentTarget`为绑定事件的元素，`target`为子元素
    - 若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素           
  - 当事件是元素自身触发时，`currentTarget`和`target`为同一个元素。

e.type点击对象的事件类型

```js
$("a").click(function(event) {
    alert(event.type); // "click"
  }); 
```

## html5

`HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加

- 新增选择器 `document.querySelector`、`document.querySelectorAll`
- 拖拽释放(`Drag and drop`) API
- 媒体播放的 `video` 和 `audio`
- 本地存储 `localStorage` 和 `sessionStorage`
- 离线应用 `manifest`
- 桌面通知 `Notifications`
- 语意化标签 `article`、`footer`、`header`、`nav`、`section`
- 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`
- 地理位置 `Geolocation`
- 多任务 `webworker`
- 全双工通信协议 `websocket`
- 历史管理 `history`
- 跨域资源共享(CORS) `Access-Control-Allow-Origin`
- 页面可见性改变事件 `visibilitychange`
- 跨窗口通信 `PostMessage`
- `Form Data` 对象
- 绘画 `canvas`

### classList

```
属性length,返回类的数量
classList.item(index)返回元素中索引值对应的类名。索引值从 0 开始。
classList.remove/add/toggle('active')
classList.contains('active')判断当前ClassList中有没有active
classList.toggle('active', '');toggle函数的第二个参数true为添加 false删除
```

### window对象

#### onload

- onload

```javascript
window.onload = function () {
  // 当页面加载完成执行
  // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行
}
```

- onunload

```javascript
window.onunload = function () {
  // 当用户退出页面时执行
}
```



#### 历史记录pushState

pushState()可以创建一个**伪造**的历史记录，可以配合popstate事件，而replaceState()则是修改掉当前的URL，不会产生历史。 

**pushState(stateObject,title,URL):**  改变网址却不需要刷新页面 

stateObject（状态对象，一个JavaScript对象，window.history.state可以获取) ，为每个历史记录添加状态

title标题（现在被忽略了）

URL地址（ url可以是绝对的也可以是相对的）。 

无论何时用户后退或前进操作，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝； 

```
if (window.history && history.pushState) {
// 支持历史状态操作
	history.pushState(this.dataset.title, 'title useless', '?t=' + this.dataset.title);
    console.log(e.state);
}
// 在历史状态中前进后退触发该事件
      window.addEventListener('popstate', function(e) {
        console.log(e.state);
        content.innerHTML = data[e.state];
      });   
```

### History对象

### Location对象

window.open('http://www.baidu.com','newwindow','height=500,width=500,top=100,left=100,toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no')
//    我们可以控制窗口的各种属性：
//    宽为100，高为400，距屏顶0象素，屏左0象素，无工具条，无菜单条，无滚动条，
//    不可调整大小，无地址栏， 
window.location ='test2.html' //改变当前窗口的地址，则会打开新的网页

location.reload(true);    //从服务器重载当前页面//       
location.reload(false);   //从浏览器缓存中重载当前页面//        
location.reload();        //从浏览器缓存中重载当前页面

location.replace("http://www.baidu.com");
//        replace和assign的区别
//        replace()方法所做的操作与assign()方法一样，
//        但它多了一步操作，即从浏览器的历史记录中删除了包含脚本的页面，
//        这样就不能通过浏览器的后退按钮和前进按钮来访问它了，
//        assign()方法却可以通过后退按钮来访问上个页面。

### File对象

### 表单FormData对象

### WEB存储

本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能. 数据以 键/值 对存在,

- localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

  ```
  // 存储 localStorage.sitename = "菜鸟教程"; 
  // 查找 document.getElementById("result").innerHTML =localStorage.sitename;
  //移除 localStorage 中的 "sitename" :
  localStorage.removeItem("sitename");
  ```

  ```
  不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：
  
  - 保存数据：localStorage.setItem(key,value);
  - 读取数据：localStorage.getItem(key);
  - 删除单个数据：localStorage.removeItem(key);
  - 删除所有数据：localStorage.clear();
  - 得到某个索引的key：localStorage.key(index);
  
  ```

- sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

### Tips

设置属性（setAttribute）,属性名为'data-'开头的，可以使用dataset来获取值

```
setAttribute('data-age', value);      dataset['age']
```

# canvas

## 基本用法

### canvas元素

`<canvas>` 是 `HTML5` 新增的，一个可以使用脚本(通常为 `JavaScript`) 在其中绘制图像的 `HTML` 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。

`<canvas>` 看起来和 `<img>` 标签一样，只是 `<canvas>` 只有两个可选的属性 `width、heigth` 属性，而没有 `src、alt` 属性。

如果不给 `<canvas>` 设置 `widht、height` 属性时，则默认 `width`为300、`height` 为 150，单位都是 `px`。也可以使用 `css` 属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用 `css` 属性来设置 `<canvas>` 的宽高。

###  渲染上下文(Thre Rending Context)

canvas元素创造了一个固定大小的画布，它公开了一个或多个**渲染上下文**，其可以用来绘制和处理要展示的内容。我们将会将注意力放在2D渲染上下文中。<canvas> 元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。

```
var canvas = document.getElementById('tutorial');
//获得 2d 上下文对象
var ctx = canvas.getContext('2d');
```

### 绘制矩形

不同于 SVG，<canvas> 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。

canvas提供了三种方法绘制矩形：

- fillRect(x, y, width, height)
  绘制一个填充的矩形，默认填充黑色
- strokeRect(x, y, width, height)
  绘制一个矩形的边框
- clearRect(x, y, width, height)
  清除指定矩形区域，让清除部分完全透明。

x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。

### 绘制路径

图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。

1. 首先，你需要创建路径起始点。
2. 然后你使用画图命令去画出路径。
3. 之后你把路径封闭。
4. 一旦路径生成，你就能通过描边或填充路径区域来渲染图形。

- beginPath()

  ·新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径

- closePath()

  闭合路径之后图形绘制命令又重新指向到上下文中。

- moveTo(x,y) 

  方法把路径移动到画布中的指定点，不创建线条。

- stroke()

  通过线条来绘制图形轮廓

- lineTo(x,y)

  绘制一条从当前位置到指定x以及y位置的直线。

- fill()

  通过填充路径的内容区域生成实心的图形。

**注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合****。

**绘制一个三角形**

例如，绘制三角形的代码如下：

```
function draw() {
  var canvas = document.getElementById('canvas');
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');

    ctx.beginPath();
    ctx.moveTo(75, 50);
    ctx.lineTo(100, 75);
    ctx.lineTo(100, 25);
    ctx.fill();
  }
}
```



### 样式和颜色

#### 颜色绘制

- fillStyle = color
  设置图形的填充颜色。
- strokeStyle = color
  设置图形轮廓的颜色。

一旦您设置了 `strokeStyle` 或者 `fillStyle` 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 `fillStyle` 或 `strokeStyle` 的值。

- 透明度 Transparency

  除了可以绘制实色图形，我们还可以用 canvas 来绘制半透明的图形。通过设置 `globalAlpha` 属性或者使用一个半透明颜色作为轮廓或填充的样式。

  - [`globalAlpha = transparencyValue`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalAlpha)

    这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。

#### 线型 Line styles

- lineWidth = value
  设置线条宽度。
- lineCap = type
  设置线条末端样式。
- lineJoin = type
  设定线条与线条间接合处的样式。
- miterLimit = value
  限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。
- getLineDash()
  返回一个包含当前虚线样式，长度为非负偶数的数组。
- setLineDash(segments)
  设置当前虚线样式。
- lineDashOffset = value
  设置虚线样式的起始偏移量。

#### 渐变 Gradients

就好像一般的绘图软件一样，我们可以用线性或者径向的渐变来填充或描边。我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。

- createLinearGradient(x1, y1, x2, y2)
  createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。
- createRadialGradient(x1, y1, r1, x2, y2, r2)
  createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。

```
var lineargradient = ctx.createLinearGradient(0,0,150,150);
var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);
```

Copy to Clipboard

创建出 `canvasGradient` 对象后，我们就可以用 `addColorStop` 方法给它上色了。

- [`gradient.addColorStop(position, color)`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient/addColorStop)

  addColorStop 方法接受 2 个参数，`position` 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。`color` 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。

#### 图案样式 Patterns

上一节的一个例子里面，我用了循环来实现图案的效果。其实，有一个更加简单的方法：createPattern。

createPattern(image, type)
该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。
注意: 用 canvas 对象作为 Image 参数在 Firefox 1.5 (Gecko 1.8) 中是无效的。
图案的应用跟渐变很类似的，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。

var img = new Image();
img.src = 'someimage.png';
var ptrn = ctx.createPattern(img,'repeat');

#### 阴影 Shadows

- shadowOffsetX = float
  shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。

- shadowOffsetY = float
  shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。
- shadowBlur = float
  shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。
- shadowColor = color
  shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。

### 图像

#### 绘制图片

**获取图片的方式**

- HTMLImageElement
  这些图片是由Image()函数构造出来的，或者任何的<img>元素
- HTMLVideoElement
  用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像
- HTMLCanvasElement
  可以使用另一个 <canvas> 元素作为你的图片源。
- ImageBitmap
  这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。

用脚本创建一个新的 **HTMLImageElement** 对象，使用Image()构造函数

```js
var img = new Image();   // 创建一个<img>元素
img.src = 'myImage.png'; // 设置图片源地址
```

若调用 `drawImage` 时，图片没装载完，那什么都不会发生（在一些旧的浏览器中可能会抛出异常）。因此你应该用**load**事件来保证不会在加载完毕之前使用这个图片：

```js
//已知图像路径
var img = new Image();   // 创建img元素
img.src = 'myImage.png'; // 设置图片源地址
img.onload = function(){
  // 执行drawImage语句
    //1.创建的img对象
    ctx.drawImage(this,offsetX,0,imgW,imgH);
    //2.文中的img标签
    ctx.drawImage(document.getElementById("img"), 0, 0, imgW, imgH);
}

//执行input[file],上传图像
function getObjectURL(file) {
        var url = null;
        if (window.createObjcectURL != undefined) {
            url = window.createOjcectURL(file);
        } else if (window.URL != undefined) {
            url = window.URL.createObjectURL(file);
        } else if (window.webkitURL != undefined) {
            url = window.webkitURL.createObjectURL(file);
        }
        return url;
}
 var imgFile = $(this)[0].files[0]
var objURL = getObjectURL(imgFile);
img.src = objURL;
```

上面的getObjectURL，用来获取图片对应的 data-URL (一串 Base64 编码的字符串)。

```js
img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==';
```

**`HTMLCanvasElement.toDataURL()`**获取**canvas**对应的data-URL

```js
var canvas = document.getElementById("canvas");
var dataURL = canvas.toDataURL();
//dataURL，相当于就是src
img.src = dataURL
```

设置jpegs图片的质量

```js
var fullQuality = canvas.toDataURL("image/jpeg", 1.0);
// data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...9oADAMBAAIRAxEAPwD/AD/6AP/Z"
var mediumQuality = canvas.toDataURL("image/jpeg", 0.5);
var lowQuality = canvas.toDataURL("image/jpeg", 0.1);
```

#### ImageData 对象

ImageData对象中存储着canvas对象真实的像素数据

**getImageData(left, top, width, height)**

获得一个包含画布场景像素数据的ImageData对像

- **`width`**图片宽度，单位是像素

- `height`图片高度，单位是像素

- `data`

  [`Uint8ClampedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray)类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。

**putImageData()**对场景进行像素数据的写入

#### 图像模糊

https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio

https://zhuanlan.zhihu.com/p/31426945

##### 设备像素比

**设备像素比(window.devicePixelRatio)当前显示设备的*物理像素*分辨率与*CSS像素*分辨率之比，此值也可以解释为像素大小的比率：一个CSS像素的大小与一个物理像素的大小。 简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。**

在很早以前还没高分屏的时候，开发写的的1像素也就是实际的1像素（如果不考虑缩放的情况），你根本不需要做什么特殊的处理。如果css中设置100px那他就是100px。

后来出现了高分屏的手机，并且在window对象下面出现了devicePixelRatio 这个神秘的属性，并且还可以用devicePixelRatio在媒体查询中进行判断。这个属性的意思就是：渲染时，css中的像素（逻辑像素）候和实际像素（物理像素）的比值。比如说：iPhone 4S它的devicePixelRatio 属性的值是2，那就是100px逻辑像素等于200px的设备实际像素。原先需要一个像素绘制的点，现在会用两个像素来绘制。

##### canvas 的 css 宽高与上下文宽高

```text
<canvas id="canvas" width="200" height="200"></canvas>
```

canvas 标签中的 `width` 和 `height` 属性并不是 css 中的宽高，而是 canvas 绘图上下文（绘图区域）的宽高，当不设置 canvas 的 css 宽高时，canvas 会将 `width` 和 `height`的值作为 css 宽高，而 css 宽高是元素在页面上的可见尺寸

但是 canvas 的上下文宽高略奇怪，它可不管像素比是 1 是 2 还是 3，它就是会将整个 canvas 绘图区域塞进 css 宽高中并且填满，绘图的时候会将绘制的图形的宽高按照塞进 css 时宽与高的缩放比率分别进行缩放（**所以如果缩放比率不同，就会导致绘制的图形变形**）

**但是上面这些都不是导致模糊的真正原因，下面这个才是捣乱的元凶：**

> canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊

## 解决绘图模糊的方法

创建的图片的时候根据devicePixelRatio 放大数倍（比原照片更大的新的一张图片）然后再用css再把它缩小到原来的样子。因此缩小后的图片不会超过自己原来的尺寸并且不会再模糊。

#### 反锯齿

`CanvasRenderingContext2D`**`.imageSmoothingEnabled`** 是 Canvas 2D API 用来设置图片是否平滑的属性，true表示图片平滑（默认值），false表示图片不平滑。

反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。你可以通过切换勾选框来看到imageSmoothingEnabled属性的效果

    zoomctx.imageSmoothingEnabled = false;
    zoomctx.mozImageSmoothingEnabled = false;
    zoomctx.webkitImageSmoothingEnabled = false;
    zoomctx.msImageSmoothingEnabled = false;

![img](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAcwAAADSCAYAAADHcPDZAAAgAElEQVR4Xuy9B3wc1bU/fu6d2d602lXvxU3uCGNsS+BQYwg9Bt5L8n8kvPSE5CWBBDDIAgPJ45cCIYW8tAe8l4DzKKGHEoPlgo2b3G1ZvUu72l5n7v1/RvasN4rKStom6c7ns5+5tm4553vuzHduOwcBuxgCDAGGAEOAIcAQmBABNGEOloEhwBBgCDAEGAIMAWCEyToBQ4AhwBBgCDAEYkCAEWYMILEsDAGGAEOAIcAQYITJ+gBDgCHAEGAIMARiQIARZgwgsSwMAYYAQ4AhwBBghMn6AEOAIcAQYAgwBGJAgBFmDCCxLBMioAGAn57L9R8A4B+jRKz5JmyQZWAIzBAEHgCAdQDwGQCwsedihlhtDDFjJUz5RfflqHo+CwD/M7PVTwvpZxq2CwDgeQD4OgDsOIdgrEQYa760MMw5IaSXXcM4Ah0CgNsAYPDc83D1iLxvj/KylF6enxvjJWo5V8+zUc+XlP+5UWR4GgDG+0BJJxynIotENg9FFXwQAB6eSkVJKDOa3aRmZzNhyjqP7POS3jVR7wcZfvlZGos75HfL4xNwy0T9YuTf5fan3X9iIUxZif8b0VmlB/UNADiZhM44W5uYidjKnT76gZiJRDiVPiXr2TXKi1t+eUgfEfJLXc5fOoIcp0KYd58j5rnwvMlYto74IJBwk/5P/lCbig0TVWasl30shJkomRJd72h9fqw2owcGo31ESuUmIsxY+0XCMI+FMMd7uBNtkNle/0zElhEmQKyEGf0SiB6RM8Ic/8mW+tgvZtgHAiPM8W0q43PinF1HG4FORJix9ouUEuZkGh85dTTyS2KsL5KR03zyv38JABcAgDQVHD2MHzkVMHKoPXIabdpD8QQxdyzYRnei8qgpKnk6TsJHnjKUpwdHjkImsousntzW8ih95Y492tSxPPWyP2oNU5qJ+FtU+Wi7jTYSlTGQRmXSS1Jue7Rpm5F2lfqFpL90JWNqcrIjzLG+mhlhjv9ASfhMNKKO7kvRfW6sKfLR+tN4/T1awonyjTYFKLc3Vv+OfidN97kYKZ9Ut3RNtHY63dfaZEaYcp//dwDYBKN/dE5EmLH0C0mnWN6rU9I91hGmtH4yEemMJqT0f7dEfSlOljCll+fIL5HR5sFXnNtoIhHFyBHQZIw6JRCnUUgmsvGwjX4YZCyiiSN6HWssG4x8cEbaRX64JOKNxns0rMcbYUoEFq3LyHbGejFI61TResi4RMsy2v/JL6pkreVNhTBHw4sR5sQjTKkvjmfX6A84uc9Ff0hHfzyOZoPx/i+aXGPNN94Ic6L+PZ3nYrRnVH5Wxpr6nMYr6x+KxvpuHZlvLOKbiDBlXSd63lNKmDJjy4vv4y3mjvzbSKAmS5gj100nMtBYf0/nqc/or9PxpimisZAfsItHTFuNfLhHe9gle8Zql9G+1sYjzJFrdSMfgLFeDNEfVZORb6w1jZEvhNFGCNF5JnoA5byTJcyp9MfJbPqZzRvvomdFRtNzvPVh6QN/tBkpeX15vPdI9MtWsru0sTF6XVruCyNfyuMR5kT9e6rPxVh7B8bCZuRzMd6mHSnvRIQ7VvmR5UZOpY61QWoiwpRkmqhfjOSraJ1He79O6uMhlhGmXGH0S2fk1N94jC79reDclJl2jA441pTsyN1So+3QjFZ4LIKIde57UuDFMfN42I73IMq4ysc4RuITq13kad2xPoai15Mms4Y58sEYb+opetv9SGIay67J3mwUC2FG7xgcb4p8srtkJ5qijGN3TJuqRr6QY9loNtqzHmt/kmda5P5uPbfcEctzMZk1zJHyTPW5GI9gEjbKiuodEw1goj8upHT0DudoXhj5/ppol+x4/WK0j/y4dejJEOZoxCl3pNGUH+1LbKwvtlgJcyLim+gIwLS/MOKG/OgVjTb9Ol3CHEmqo9ll4TibLGIZtY5FXCMfqMm+GCRZpbVJidBH2wSSjoQ5chQzcqen/JXMCDP2hyn6BSmPHMeyfayEOdamouj+LkkYSz7J5lMhTLl/S/eR55hHI7yROhePcsRrrBFw7GjHnjMWwpxoFBv9To5lhBkt3Wj9Iu0IUxJoJFCxjmSmO8Ica6QhgzgRocbeFVKXcyS20yXMsRb+oz9yEj3ClElkOoQ5cn1VslCshJmqKdmxbDfe5oWxpmTn4ggz+ikcaevRSGbkCFHe/JauI8x4EeZoI7JYRpgTkVmsU7KjTVnLthtrOWy02ZrJEuZY74BYdJ/SG34qI8xoIeXt9ROtlcmHsMea0hpZfizgJvqiGWtufErgpKjQSIymQ5ix2mWiNZ3oUepUpmSnS5jyl/RYU/S703iX7GjkON7SwmgffbHuDkxRl01as9EfedMhzFj7+1gf+PIoJvq5SMUIcyz5ZP3k2YyxPAxN13ATvY/HW8KQZYv+EJwKYY5mi5QSptR48wjPCyNfmmMtMo8m+MjdjtFfOfLwfDzg5PLRi/rRu2RH200pyXtZGnoJiQXb6RDmdOwif62PHNmNJk+ip2SlNQ55c9Rox1xi3bQz3RdELGuYI7+2x9qYNNpOZRnbkZvd5hphSvpKR6ii17xi2UAW6whTfllLm4NG2xU+0e7s0T4axyKPWKZWRyP/WMpJz8Vo70P5WZlohDjd52Eiwpxoz8lIm05EmLH0i7SYko3eySkJNJYhRuYb60UWnU+qSz6DJx/ungi4kWuVI49ljDx3ONGRmOl2nOmUnwjb6RCmLFesdhmJayznOqWXS/Q5zOjzkPFaw5Q3BUTrIcl2BwB85ZyS6XoOM/rDY6J+KuUdbZ19ZH+W7ZroF+J0+vV0y47UeWRfnM4apixbrP19KvlGnsMcbVObJIfUb6dDmNHkL+sl9SFpgDDWcsx0bSOXn4gwJxrpjbUmG30OPFon6WN0on4hE2a0S0W5jml/WE91SjZegLN6GALTQWCiKZ/p1M3KMgRmMgLjbcScyXqlVHZGmCmFnzU+TQQmmvKZZvWsOENgRiIwG/ZypCXwjDDT0ixMqFEQkL6Y349yvD3W2iADjyEwlxCQpiilS44cFavTgrmEUdx0ZYQZNyhZRQlGQH4RRIeYS+e16QTDwapnCEQQiHWPAoNsmggwwpwmgKw4Q4AhwBBgCMwNBBhhzg07My0ZAgwBhgBDYJoIMMKcJoCsOEOAIcAQYAjMDQTSgjDrSmovgDKusX7bNmFuwM60ZAgwBBgCDIGZhkDKCfPR3JVZ3ppVf1K9/9G3HrQfOjrTAGTyMgQYAgwBhsDcQCDlhLm5ZO1l3h/e9arq6Rfv2bLtBSkyALsYAgwBhgBDgCGQdgiknDDv+/QXn/Q/9NVvah/7/RvLA33X37p1q5h2KDGBGAIMAYYAQ2DOI5BSwqzLWJER/Px1b/nrv7xa/d+vNunrf/WpBwYb5ZA8c944DACGAEOAIcAQSB8EUkqYD+VfvM7987tfD1252sQdbqL6u5+486GdL/0hfeBhkqQCgbqqKqXeVqiwqXxKlZ8PQ1ZWaPOxreFznZWmQibWJkOAIcAQSClh3n/jnT/yPfyVe0hJHoA3APrv/eSlLc/94haEEHspzuG++XjOVTqv3qPjBF6HscLnVAZ8LcvyfVVbt9J6AKlvsP4xh/sHU/0sAsOnC+SrjGuUk+y0QeJ6SMoIsy5rvT5060Vv+R67SwpBM3ypn/6/4+otv/1UvfOwFH+TXXMUgR8U15h1CGcIQM0iEZ1ancYRzBWdx7Ky6AtbtxLECHOO9gymdjQCjDCT3x9SR5jWlRf6fn7Pm6Fra62y2vz+E6Lu7p995qG9rz2ffChYi6lEoA4A90A1t6TSiW2FK4sQhmIRuGIqCN3IH+zS9rV280EU8liEcP2xY6FUysraZgikAwKMMJNvhZQR5qbr76jz1X9ls1hRGNEaOdyguefJ5x/7869uTz4UrMVUIvAlqFYsLFTyTh9RkJXli0GlWEw5rgqE8GnsCZxCR1pOIw34AMC3uXufdGcXQ2DOISCdW5eVls6vy2npHLucZufZE9ctUkKYPylcoxncsOZN7+PfvhQw/gft1E/872HDT7deu8m+tyNxarOa0w2BJysrVTa7RaVShlTBC5auFlT8GuD41SgQPog97gN84+mDGERXGHTOevtHrnSTn8nDEEgGAowwk4Hy2G2khDDrMlas8D/x3TeCN30ib6Ro/O7DId13f3zrQ4fffSW10LDWk4mAtKYNOq8eBF4vfOKCNTTDtIaqlWvAFziE7c6D/OHTBwnhBjQq3H/fgTcHkikba4shkC4IMMJMrSVSQpibrvns3b6Hvvqf4vySf9Ie2Z2g+8HP//uRP//6jtRCw1pPJgKPFdeYAwBmDsLmwPWXryW5meuITrMWu72HcK/9ELf/RCNg1IFF1FH/0YudyZSNtcUQSBcEJM9okSnZH971amRK9ukX75HTzGNa4qyVdMKsq9qoDF1c8Lrv8W9fAQp+VM00j//xgOrXr1xTP7C3N3Gqs5rTCYHNFWuzIQTZgCE7cNvV60hZfi3NMKxDdkcjbutv5PccacQImkKUnvnhtq1N6SQ7k4UhkCwEGGEmC+nR20k6YT6UuXyx54ffeiN4+1XFY6mu2H7Ar/3WT256qOnvb6cWHtZ6shC4f+3N0nRDCQApEa9eWy2U56+iVnM17rOf4tp6TvAfHz+FED3CidyRutd/d5Q5MUiWZVg76YQAI8zUWiPphLnp8tu/7tvytafExeVjao76bKC7/6lfP/LCf301tfCw1pOFwL3X3bGQE4SFgPGC8KXVS4TKoqU017IE9wy2ck0drfz+460I0D4E4sd4Yf6+zfX1lJFmsqzD2kkXBCTf27Iskg9uOS354pbTkk9uOc18c8fXckklzBc2buQOqXP+6v3xf1xD1apxNdE89Ju9xj+9teG+rj22+KrMaktHBO7b+MUVQOACQLBCqFlZKS4qm0eKcipxW08Pf7y1lz9wvAco2gEcaVju699xtKqKniNN5vUnHQ3KZEoIAowwEwJrzJUmlTAfti5b4H7wq68H77iuYiIJFe/vcRu/8fh1D3bu+mCivOzvMxMByVkBwHqcD27U/tnVqyjmV1EMq4TVS4vFqrISUpxXzLX3DnJNHQPckTODSBQbcDDQoH/ngx2BAITz8iD85X37wjNTeyY1Q2DyCDDCnDxm8SyRVMJ8oOamL3h/9K3fiksrJ2wXd/aDdtMvf/bIi7/9j3gqzOpKHwTqYD1vgU6uPUfL81dfuga0qjWAuDVkVVWusKgsj5QX5OKOXgd3ptPBnWofglB4BzfkatD86c2GsEbwm8Do/07nLn/6aMQkYQjEHwEpqpNcqxTdKTIlW//l1XJaivYkp6WoT3KaRX+Krz0mJK54NUcpRfd/7psveh//9o2gU8dUrfaBX+4yPfP2hh8M7XPGVIBlmlEIPA3VitM5YaUuiBXCLVfUCjrFJYjja8XqhZlCVbmFVBZl4o4+D9fW4+HOdHiQN9CA+mwN2mf/2iAA59aCz/39wZPuGaU0E5YhMEkEGGFOErAEZh+VMJ+s3KC6q+nNYDzbrTMtLQ888MXXA1+6eWGs9Sre3jWk+8Zj19T37d8da5lY8tWtX88zj/6xIJXYPJvzq7UAoKUUtMFPf7KWWIyXILWqRlxQYhQrC42kJM+Ie20B3D0QwJ39Aezx7uQ6+3cq//LeLo5SG4fw4H0n3mNr3Ik1E6s9xQgwwkyxAaKaH5Uw6yov+Z24YsE8olUL8RIV9dtN3ifvXk5zrVysdUq+ZbV3/+wgqJRDsZaZKB8Khjl+7xFU39xwyUR52d8Ti8APzdUmvxpMHFGa/Hd8skbMy64FnaqWlOZrxKJsLcnP1uBBh4AGHQIedISR3bmHa+nerXpl2x4QaTcA311/4K/diZWS1c4QSC0CUtxgWQIpfrCcluIIy2kpnrCcluIKy2kWXzi+thuVMKUXmevSFY+F/uWqfwlfuToD+NEdDMRXlMTXxu8+HFD94bXXtG/v+Q7zVZt4vCdqYXN+tZUDtYWCaA184YYaoSxPclZQI+ZaFTTHrCDZmQrk9AByeqh0x332j/nT7XuVr3zwMSDUikTSUr/75daJ2mF/ZwjMZAQYYaaP9cZcw3y6ulrRiXNvC19T8/3AZ69ZQnMs6SP1JCVBLi8ot77Xpnr1w6eMR4/96u6+Ru8kq2DZE4BA3eqbCwmlRQjEwtANl6wSywsuopaMVcRq4khmBk8zjRzy+gE8fkC+AMWd/UcVp1oO83/bcxQwHAeA41tef1a6s4shMGsRYISZPqadcNPPZkv1wtAnL340+PnrrxEuWjz+4cn00SsiCT7VRtW/ffkDzTu7Nz14ZvuONBRxzoq06cp/nQccNw8onRe+/KJl4ryi5STXsoyatJgaDYgadRgCIUDBEEh3rqO3iTty5ozyw31NgOAAwfjAI39++gBCiJ3FnLO9aPYrfv+Nd/5I1tL38FciPmNJSVTsCm8gAoT+ez95Sf7Hlud+cYucZs/J9PvKhIQpNSFFkiDLc74RuOHSr4VuvqIIDNJejTS/QmFQvb3Lxv/pb88p9+5/dHNfY3+aSzznxHvghi8tFVF4OQK8VLj0ggXCwtKFpDB7AdWqAXQaGL4LIoBIhu/cmY4uvvF0l2LHwS6K6C4lKHbUPfvELgk49jKYc91nzijMCDN9TB0TYUa+VuZddonvqlUP+++8sZZUFk2qbDJVxt2DoHr2tUPKt3Y9sqRc+yJzD5VM9MdviwKgW2EjroIBFLp9fjVGfDXFqDq8bnkpWVRWJhbnloFKCVSlAOkOhJwlTEKBO9PZz59o7uP2nejDhOxE4dAO7qUDO0EHArSCUA/b4rZJLX0QY5LMdQQYYaZPD5g06dVlrcoV1lTdH7p9w2dCV19sHiviSKpUVOxo9Cufee1Vzbs7Nz0wcPB0quRg7Y6OwEbYyF0Bzbi71MCJNUsuFpWKixGGi8OrlxSIiyvzSXlBPuUwAM8BcBwApWd/EmG29djxqTa74miTnYaEHcjlbdD/5Y0dXFgV8JtswfrW1vPzUswADIEZjMBwfNhzV+jWiyLOCnyP3RXZMTuWeuqn/y+yrq/e8tuIE4N65+HmGQxJWog+acIcnqJdv56nHu3G0Ibae4Of27CU5FpTroy0i1K59b0W1avbnjIeO/k029iTcpOMKoDk3QdKgQcv8OHrVtRSpeIS4FCtcOFiq7hsvkWcVzRmZ8LtvS6uudPNnWxzQSDQwPU7GxTPvNoQFqjXrMceZvP0tDmTavIIMMKcPGbJKDElwpQFk3zDBq6qfSRwx7WfEi5elrINQdyJNqL6/UvbNG/u3PRg287hNS12pScCdaXr1cEhQWNQ+NXe266upSbdJVTF1wqLy01kXnGGWFYQOVs2UgPcM+DnOvt9uK3XDx7fTq5nYIfy+fd3AifY1UEYure9IW7nddMTPSbVXEGAEWZ6WnpahDk82sxarxeWZH9NuPETXw/eclkxNeqSp2koDMo3Gmyq5999Rruv8bH7eg8MJK9x1tJUELjHus6gAZ9BBM4g/NuGWpprqaVaTS0pL9SJJbk6UpgzZgdCA0Nh3C/97CE05NqN23t3qV58dxcScF8Ywn2PHnmvbyoysTIMgXRDoM668kJZJt/P73lTToeurZ1wOo/ff0KU8+vu/tln5PRDe197Pt30nGnyTJswZYXrytfVhK5etyVw5w2XkPklcat3LEBR1wConvnrQdU7H21ZUqZ7mW3smRld7zHTUrNXpczkCDEHv3RzLS3OrSUmfS3Jz1aRfKuS5FjGnKlADjfFQ26KhlwUDTo+4k+3f6R88f2PMNCOMPAdj+x9pWNmoMCkZAiMjwAjzPTsIXEltkeyV+f4Vi+8L3T71Z8NbVibmSgPQXzDQb/q2ddf0by3Z9MD/fvOpCe0TKrREKhbeX0+QWIe4lB+6FO1q8WKwtXUbFhNsjJ5ajUpiNU8plsp5PFRyQkF8vgp7hlo5E+2H+Le3tmIED4lisKpx957/hRDnSEwGxBghJmeVowrYUoqSkGij7Z6b/HfetX3g/9+0wXDOx3jdVEKqrd2nlL9auuvuFMtv9ncvc8Xr6pZPclBoO7yfy0XAcoRiOXhq9asFCoLV9KszBU0Q88RsxFTkx6POavgDwD4QxT5A4A7ek9zx1pPKT7Yd4oCOiQCOfSjl35/KDlasFYYAolFYNP1d9TJLfjqv7JZTosVhRM2LPngli/NPU9GpmEf+/Ovbp+wMMswLgJxJ0y5tU1X3Pa253ebr6JmQ/xMQAjo7vp/O63v772CxUGMH6zJrKnuhs9XCZQuRgBV4U9cWEUWlC4W86yLqV4DVKcF6T7mFRYAhcIAYQFwc1cHf+R0B9fQ2AEIdmMCux95/ldxjWqTTFxYWwyBaAQYYaZnf0gIYW6xLC9wf+tf3wx8+zNL46228uVtvYa7Hr/mQcehA/Gum9WXGAQkZwWbAdBi2IgOb7SuAAwrCdCVQu2KCmFRaSUpyqugaiWAWgXD97GuYa8/IiBBBNzS1csfb+3BHx/rBZHswsHQTuU7O3bRbr+wGBaLt8LWyMaHxGjFamUIJA4BRpiJw3Y6NSeEMOuWXXm99/HvbA2vWTrO229qYnNNHaB98Jf3bXnt2cemVgMrlWwE6gAwwHoMVf04dMGlqzHHrQaELgqvWV4oVlUUieX5hdJ6N1VwMO66N5EcGJBhRwZcS9cgPtlq4w81DSJB2AHu4A7Dn7ft4FSKkG9wKFgPx0LJ1pO1xxCYDgI/KVwTmV4Z3LAmsjPW+/i3L43Ui8dcsRi1afUT/3tY/oPhp1uvldMsWtPULJUQwrz/9q/80fvYN/6NWjKmJtV4pQQBtPc88X7ethPXxDvIdfyFZTVKCLwAG7mjVUc5k8vE2S+/sJbyfC3FqDa8ekmWuHx+ljivOAvQua4o3yeAjmvtduJT7U7ueLMTguEG3u7ervnzew04jHwhg+hn69us7800BBhhpr/F4k6Ykuu8wJdvfDNwz7+tSJT6yr+826X97pPX1A/tb0xUG6ze+CHwZGWlymczqQPKsCp809W1oklbi3hFrbC0MkNcWGoWywrMw63FSJZSVtzV70VtPT6+tccLXt8O3GdrUG19fycg4tCAxvmD5ned8dOA1cQQSDwCjDATj/F0W4g/YS5Y/0nvT773Urh2hXq6wo1VHp9sBf0Dv/7uw28995NEtcHqjR8CdVlVeiXCOhJU6b2fv6YWsjJqqVZdI84rNIilBQZSlKOfDFkOE2afPYT7bEHUPRBCTs9O3N67U/OXd3dSjAZDwdDAY03bmROL+JmQ1ZQEBOoyVkQGGf4nvvuG3GTwpk9ExfGanCD87sORpQndd398q1z6ocPvvjK5mlju4W/6eMNw/61f/I3v0W9+kWRnxl615Fx7EqMLaZek7ns/faekseHaL+/bF469IZYzFQjUZayQ5uaHf8Ev3VxDirIuAaO+hhTlqMWCbA3Js0764wrZXQTbHATZnAQNOndzze07Vc//bTcltBsrcVf9gXe6U6Era5MhMFUEGGFOFbnklYsrYT6auzLLfcdNb/ru+0J1rCpIZ4ZUL//dGbx6jYnmZcVaDFR/erNdf+9T1zxoP3Q05kIsY0oQqKu6JpeoxBxEUG7wlstWk6LcNZBpXC1mm5U026IgWRmT3xzm8lDs8hLk9FDcZz/InW47oHxr10GR0DMYoaYt7z/PHFqkxNqs0akiwAhzqsglr1xcCbO+vPZy9xPfeyV8aXVMDmWHnab/7qVt/N92f0e8ePmm4OevvS5WJ+7c0WbQ3P+Lbz7y/vNPJQ8u1tJUELj/sptLMOVKAWhJ+Kq11WJFYTWxZlRTiwkTs5GjGYbJe7fwBSjy+QH5ghR39p3gjreeUGzbewIQOkIRPvzoS787MhVZWRmGQKoQ2HTNZ++W2/Y99NX/lNPi/JIpi4Ts55fydT/4+X/LFT3y51/fMeVK53DBuBLmplu/9JT3oa99neRP4B84LIDyrZ129fN/e0az59CjktN0yYk7XZr79cDNl349dPMVReMeYJcMFgyB7rs/fVPRfvj6+m0scHA69+FNn/zsAuBgAVBYEL581TJxYdkykmNZRg2SowIdSPdJX6HwWScGoTDg1p5W/vDpNsWOQ60UyF6O8nsefv6XeyddJyvAEEghAowwUwh+jE3HjTAlp9quO29+y7f5ixeN1zbqs4H62TeOKN5oeATrvX8ZSXb1Cy7/ROCq1Q8Hv3D9uoncQKmeea1ZW/df12627TsRo74sW/IQQBQANkMdCm/sXsZRuoxiWBa+5IL5woKyBaQwZz7VqAA0ahi+T/aSnBgIwjknBt3d3LHmLsXeo12UkI+oEN6t2nZkd36rW3wXyslW5sRgsuiy/ClAgBFmCkCfZJNxI8zNRWsv8T7x3ddCV6we0xce//GxkOoPr76hfGPnveORXJ11Zb5Ye8HmwGeuvS18xYVGGOOwLtd4GnT3/uKLD2//y28nqTfLnmAEpG1ct8JGXLV+AIXyFq9CHL2IAlolrlteLCwuLyGlBcWg4IEqFSDdJ31JDgzOOTLALV0D/MnWfu7AiQEkiDvBG9yh/Mv7O70qEp7Xpwh9GdjGsEnjywokBYG6qo2R9fvQxQWvy436Hv/2FREBpvJ8jCK95vE/RryjqX79yjVylvqBvb1JUXYWNBI3wrz/ljt/7Hvoa98hRTn/BAvyBUD5yrZu5V/e/TW3r+WJevtHromwkzoSNYmfC1637p7gv35yPs3857jCUr3a7/30VUWF9cb6+noyUZ3s78lDoA7qMKz/AEN/FhZXF9QIlNQijGuEi5fmiMvmZ4vzinIAIwCEYfg+jQs3dzn4U61D3OHTDhQKN4Db/6Fy698bIBwOQEZGoL51W2Aa1bOiDIGEIcAIM2HQJqTi6b2pzon0Q3O1yfn/Xf2m7+GvrRkpJW7tBtUfXv1I+daHD9Qf2w+2qgUAACAASURBVPYuQsMzdTFfdVmrVoSur3ks9IXrrxSWzvunzSHq3718Sv/obz/1wMDB0zFXyjImHIG6qiolDGQrQRVUhq6rrQGdppZyuFZcPi9TmF9qIRUFmcNHieTfNCTCHX0errXbwzV3eJAnsAPZHNtVf3lnBxWxS6sF9/dP7jgfvmEa7bCiDIF4I8AIM96IJra+uBDmA9kr1/h/cd/r4avXnPXYIl2UguKDfV7lf7+6Vfv3xgen47uwrnBNpri04p7gbVd9IXRtTRaozp9C4A+dJNrvPvn5h/e88kxioWK1TwaBzfnV2iAhOl0AtJ47rqmhZlMtaJQ14rxik1hZaCRFecazp4Al0pxMzf+cF/cOBnH3YAB39gWx27sDd/Y38P/z3g6KRTsX0tjqO9+2T68FVpohkBgEHspcvliu2fPDb513VnD7VcXxblGx/YBfrlP7rZ/cJKcfavr72/Fua7bWN81X1VlYNt105w+9D33l+6TkrEMK6Wyl8k9vn1G/tu3HqMPxh3hMidXV1WH02p7r/VdcXBe84/oVtODsmU3k8Uu7ZV/a8r+/uGWyo9fZatR00Ksuc7VRAV4TAc7o/8INNSQ/+xKq19aIpXlaUpSjJQXZU9gaO7pmyOYQuQGHiAaGRGR37eTPdOxQPPf2ToqhF4doX33rNrZGkw6dgsnwTwgwwpxZnWLahCkdBwl9+qK3fD/85jppeo0/3kqUv3v5ff7Nnfc93LEz7lv7H86urvBfvvrR0B3XXR9es3TYQ4z61385rn/k99c+4GxsmVnwz15pH125IctPSDYWUVbw5kvXiMW5a6hRt4bmZalInlVJss1T2Bo7BmE6PQQPuQhyugnuG9qPmzr2Kd9o2I8QbUFI2VK/7c+tsxdpptlMRoAR5syy3vQJ07ryQu+T97wZvnqNVfnmDpvyhXf+W/Hx4cc2d+8bTBQUj+cs0zmrFn0tdNOl3wjeckUxd6pN1N39s88+/PHrf05Um6zeySFQt/7mQhKiRYBoUWhD7SpSnr+KWjJWEauJI5YMnmYaJ++sYCwRvH6KPT4Kbh/FPQPH+JNtR/n3Pz4KCI4jQo5tef3Z45OTnuVmCCQHgU2X3/51uSXflq9FnLCIi8vjLoB0pE++dPc/9Ws5/cgL//XVuDc2SyucNmHef8Pn6/33f+FB5V+3H1a93bBlcanu/27dmpzgvVvmXXaJ56qLHgne8aka3Y+fe2HLn3992yy104xT6wfrN1YqeUUFoaQy/Mk1K4V5JRfQnMyV1KgDatKDdI/bFQgBCgYBAiHg2nvPcMeamhXbD55BAPsJQvseff43++PWFquIIRBHBBhhxhHMJFQ1LcKUwtHYa1e+TTEMqt9uuPeBwcaTSZD5H5p4xFqd57tk+WZSkLNK+dzfbqwf2teebBlYe/+AwPA26Pqb7lwsirCEIrIktP7CRWRR6SKxIHsRaNVAdRqg2kn7Wx8b5rAAkkN+FB72+tPBHzvTwe050oFFugdEYQ+/b9seOJZNALaRegB2/Ih12LRBgBFm2pgiJkGmRZiPFlxkCWg0X9I5hKe+P5i6rfvS1myRd35O3dX31ibboa6YNGeZEoHAWe8+dXWInBiopkAupICqhZrlZcKSijJSkldGVQoApRKG7/G6RMmJAQEQCeCWrj7FsZZebt+xPkTILhwI7zT8dc8un14RhlYQ6oG5UYwX7KyeqSHwwsaNkeWIQ+qcv8q1eH/8HxFnAlQdtyX+UYXUPPSbyP4S45/e2iBnuq9rz/l526mpN6tLTYswZzUyTLlJIyB595HIcvGxY+iQNnsdiLgGEF0XXrs8T1w2L1ecV5QHHAaKOZDuibi4Mx12fKx5iD9w0o4EcTv4AtsNr2/fzgUVIV/2ULD+2LFIfMBEtM/qZAhMhAAjzIkQSt+/M8JMX9vMOMmerq5W9PSAQq0GhefKS9eJKlUtcPw6ceV8q7CoLIuUF1ip7NlnDHeH01Uat/W4ueYuF3eqzY38wQZsc2xXvPS3Bn1Q6QHweO/ua/ROtw1WniEwHQQYYU4HvdSWZYSZWvxnVevSmrYTXBqFn9f4/2VDjWg21lAlX0MWlWeIlUUZYklexrCTgjh49xkLONwz4McdfX7c3hNAHl8D7rZtNzz7VkNIQRwAakd96zbHrAKdKTPjEHjYumyBLLT7wa9G/McG77iuIlnKKN7fE/F+ZfzG49fJ7T7YueuDZMkwE9thhDkTrZamMv/IusDgA62BB9Hg+9z1NTQ7s5boNDViRaGelObrSFGOPtGi4367gAaGwrjPJqAh1w6+uXu75g+v7hAxGVCFlAP39W4fSLQMrH6GwHgIMMKcuf2DEebMtV3aSf7owsstIiXWEA9W4cbL15DC7LXEoJfuapKfpSa5ljhujR1dfTTkFrHdKaIhl4gHHR/j0+0fK1/b/jEmuB34cHv9jtfYLuq06zlzSyBGmDPX3owwZ67t0k7yupXX54NCyAeC8gPXX7qalBesJpnG1dRq5qk1gyfWjCnE8Zqkmm4vxW4vQU4vxb22w9yp9sPK9/ccphROAcDJLW89l/SjT5PUgGWf5Qg8UHPTF2QVvT/6ViQ0obi0MmnvY9zZH0FZu+mXP5P/8ciLv/2PWQ7/tNRLmoGmJSUrPCMQ2HTJdWVYVJRSRMtCn7rkQnFByYUkO/PCYUcFJj2S7om+kD8I4AuAdMcdvaf5E62n+A/2n6ZADnFUceDhl54+lGgZWP0MgfEQYIQ5c/sHI8yZa7u0k3zTtZ9bRCmtAkCLhCtWLxYWli4hBdmLqVaNQK8ZdliQ8CsUBhQKAwTDwLX1tHHHW1r5nY1tGNGPxTD9uPRPuz82Qzk5Clspc2KQcGuwBkZBgBHmzO0WjDBnru3SSnJKKbr/9i+vBBEuQBitDNeurBCryirF4rwKUEuOCpQg3RN+SU4MRBHQWScGPdzRMz2KPUd7gJJdOEx28W9v353Z7RRzYaVwKyTHhWPCdWYNpD0C0vMhC3n/5775YmRK9vFv3xgRXpfwJf5RcdI+8Mtd8h9Mz7wdcWLwg6F9zrQHNskCMsJMMuCzsTn5ZfDgHd9cK4poLQBdG167rEBcNj9frCgsAP6cowLpnsQLn+6wKY422bh9x20gits5b3i7/uUPtgc0EM7rhvCXYV84ieKwpuYwAowwZ4fxGWHGx46objgMcp3kRRXqASQPcdJv1l91sJ6HUuDBC3z4xup1oFKsoxivFS9YlC0sKssRywuyAaOznn0S5KxgLJC51h4nbupw8SdanBAMNXB254ea/3mvAWuQT40433c6d0UC6s56QwEMuy0898DPib6ZTjZlhJlO1pi6LIwwp45dpGQdAF4MG9FQdTM275tb62N1paVqjdOiEhVBtefT16yjRkMNKPkaYUmFmcwrzhRL8jKHCTOBzgrGMiHq6vdxHb0+3NLtQ77Adq7Ltl353MvbIaR0AYCr3v6RdJ8L1/AH3bGNG1HV1uG125R80D1ZuSHiIPWupjeDcwF4Wcc609JIvK7AA1+MOCsIfOnmhanGQfH2riFZBt03Hov4s63v27871bIls/269esju/jrt43uc5oRZhwsUgd1OL/6NS7ozMYqUz/p3vcpsR7q50RUDCk26ZCH6BU80oXvuK5GsGTUIq26RpxfYhDL842kOM8QB4inVAXut4dQjy2MewdD4PQ0KFq6PlT+9sUGnhCbT6m0PzZHHE1LPn5v3bgRVw0MoGNZWfSFrVsJSsEMCCPMs92YEeaUHueEF2KEmXCIzzZw78LLLcpQ0MJhzhLOMGGSqeeQ0YhB+l7hAUSkmLVTYJzTrQG3X0tDfo1YW72UFOcto5aMpaTAqiG5Fi3JtiRha+zohkYOl4CH3ALYnCLuG2rkmtoble9/1CiqFC6k0jqJUTurR5hcODz8QYyHXAgPDCHk8CABUD+HhL7NZ3aeP4iXpOeEESYjzCR1tSk1wwhzSrBNvlBdxfpKAKGSIlwBZoOaZppU1KBVU46j0g94PGsJE3xBFQoEVcgfUglrlpSIi8qLxaKcEpphVNAMg4Jm6OMYx2tytkHeAEFeHxm+t3W3c8eb2/hdh9sQx/tAyfmogvdNrsYZlJsAwoQAFSlCdifCdicghxNhwEcQEo882LTjaLK1qau85Hdym+KKBfPkNNGqhWTLkuz2UL/dJLfpffLu5XKa5lqTuxNuFMWRI+JWFrR3/+xgJItKGZmqTTZeyWoPBcMR/Pm9RyIzrvXNDZeMJgObko2DZerK119IsbgKAbqQZJr0kGEwUKNOTzlMgefJ8H2WXigQVNBgWIGCIYWwekmGuHKhSagqywC1ClG1CoFambo+JgWVls5khgXgTrY4uEOnHfzeYw7gcAgQDg/fZ+mFCEHDZEkIQkMuwDYnQkNOAIq2AUffr29q2JZs1RlhnkWcEWaye97Y7THCTIEtpBEmBjqPgjhPzLLk0AxDDug0OcSk14BBqyF6jYZq1JhqVRikn7RXcZhGUscl8YKJhgQOCWEOQmGelhZohaJcHS3M1lIFj0CpAJDuqboE8eyZTEEE3DPoxdIGoLZeL3BYoBgJCGMxVaIlpN1AiKJAkKJQmCKXLyD9wOkJYqfbgWwOJzfgcCCgjQTQofqW7Y0JkWGcShlhMsJMdp+bqD1GmBMhlIC/31tZm6UMQRbikFUstJYTg66CqpXlND/bQnLMFmo2WEmmiaMZRp6ajVyiQ1wlQMWxqyQiBkHEiAAiBq0SjDoFMegU546RoEQFio5JR0IBCAGgFJDbG0Zufwi5PGHAmMCwxGh2bcxyeSlyeQhyeQkedDpwr22I6+ofAq+/jbO7W1F7dxtg1AlhobO+66POmDCMY6Yfmqsj05KuS1c8Jlcd+per/kVOh69cnRFpkk+86+E4qseqmiEI8LsPB2RRVX947TU5rX17z3fk9Cb73o7R1End1/8MATcWMZ+GakVPPijUflC4q+cvRVr1UoLxUnFBcTEtyi0iWRnFNNeiELMzlTQnUzF8xEI6kyjd2cUQiBMCyO4Skc1BsM0pop7BHr6ttxsfb+1BYeEQcvkPqj8+fgiHkS9kEP2bu/clff2WEWacDM2qmRYCjDCnBd/0C78AG7leOMDb802cUFVZglXaYkEBJbSssIhkZxRTk6GIZJnN1GIy0wxDBtGoFKBVK6hGLY/Ezh7sZxdDIBYEpJEzPTd6DoREHAgK4AuKyO11IYfbhW0uFxpydXK9tg7c1CWNKFt4j79FtftkC6dShHyDQ8F6OJb09VtGmLEYl+VJNAKMMBON8AT1RxwXQDNu3VCewXG6DIQgQ8i3FIFGXUyUfBHNthSC2VBIdJoimp2pIRaTlmYatVQxvM539scuhkAsCET5y0VD7iCyu4LY7gwil7cHOdw9uN/WA4FgG3b5W3H/YCsXAju4/HZ06oSddvuFxbBYTLUf3aerqyO7pztx7m2y2uFrar4vpwOfvWaJnKY5lliQYXkYAhEEkMsbSSu3vtcm/0P16odPyWnj0WO/ktN39zWeLzAGjmxOMM4dbJg8N25EQ83NuBvlFhFEigBwkbiwZCG1WhZQo3ahUF5goiX5RrEgy3TWMbkqOY7J46wrqy5FCEi7f6UNTdK9e9DHd/Z5UVuvDzndTVyvvYk71daERPEMIuSM/tTpMyqDT7A1FYr1MLr3klRowQgzFajPrTYZYc4Ae0teVTYDIIk0D7bbrQpQWgjFFrGiuAQsphKqVZWIRbl5JDszj2Qac6lBp6Z6rQb0WjWoFEAVCgTKFO4snQEYz0kRBQEgLO34FQC8gSDy+IPI4wtyDnc/9A8N4J7BfuzxteNBVxvX0tWGQOgTAmJfTn9jr6rJRLphn5hO4cwYYc7JXpxUpRlhJhXuKTc27ORaIk39sqs0do7TYkBasTA7G5s02VShzoZ8S7mo11WAVlVBciwZJCvDDJmmDKLXYNBrEdVp2ILmlOGfpQX9QUCBIEAgRDm7w4X6HS7cZ3chr78Vu7zNuNfWCmGhB3mCPdDX10MReAwYPP53B7wA28hm6QRmCtzhTdYamy3VEd+qoU9e/KhcPvj56yM+ToWLFkd80k62fpZ/diOAT7VFzryrf/vyB7K2mnd2b5LTD57ZvmOqKLAp2akiN8lyP7KuM7iox6gA3iBUL1xC9JploFEtEReW5ZGyvFySa82jFhMmZiNHM42MMCeJ72zPjtxeAI+fSneus38At3YPcCdaB7A/cATZPUeUx5qOIEIGRYXCtvnUtsGZigcjzJlqufSQmxFmethh2lL8R+EajdEFGkHh08DyRSVg1pcQpbKElhcUkTxrITUbC0mmwUjPegkyULWKpxoVB2oVd/YYyrmIH9OWhFWQ1ghIu1+lSzo7GgwTFAwS8IckF39ecHp9yOnxYruzi+u1d6Lmji4uEGzFQ+5WxbHmVkEJbi2A+/snd5z3dZbWyv6zcIwwZ5jB0kxcRphpZpCpiiPFjXQVBhW5Acy7luVkUqPRjBGfSfKtpWDSlVKVslTIMudRaV1Tr5VGm0piNqqo2agE7lwAZnb0ZKrwz5xyw8dFzh4bwS63gBweATu9YXC4B5HdOYB6bYMQCDZzbt8ZrnuwWQyFbJwvOMg3d9o0KBzsFI2hn8+S0Fl1Wev1suHI8pxvyOnADZd+TU6Hbr6iKGJcg3bm2JlJOj0EJJeX5y7V27tscpr/09+ek9PKvfsjU/qb+xrjEmyATclOz2xTKh0ddBnmZVWKGqhECFeKC0oqxJzMSmI2VpCiXC0pzNWQPKsWeO7ssRPpzq7ZjYDkmeichyLcZw9x/fYg7h4IoQFnG3T1tnPH29qwIBwXg8ETqmMnj/tDimCBxRm4q6lp1sWXZIQ5u7v6tLRjhDkt+GZU4Y2wkbsCmnF3qYGD0oxcAFWuyNFcUl5UQq2mYqLXlJD8bCu1mrKJ2WSlOq2K6jUq0KlVVCJNyWUYI88ZZfNxhR0+V0kAiSKALxCWftgfCKEh9xCyu+zcgN0OLm876rV18M1d7SAKXWIo1En2N3dpNBDu7obwb2Df+U/uWYIMI8xZYshEqMEIMxGopmedwwF9YSOuggEE6zP0AFiPlCo9sZrzRJ0mH1TKPDE7s4yY9KVUqyyjuVYDsZqNxGIygEqJqEYJoGYbBdPTulOQKnQ+qgqyOX2czeGFfrsP+wLtyOHuwP1D7SgY6sT+QAfpGeok4bAL+YLOvJ4DriNNJpKXZkdGpoDApIpsmXdZJPSS76pVD8uF/XfeWCunSWURmz2bFKrpnxl3n9/Lpnr2tUORqde3dj0ip5eUa1+U07du3Rr34AqsU6VRP3m0sjZLRCorApIVWly+WMzULaEa9RJxQalVLMvPEguyrVSvBdBr0PCdXbMCAeQfPi4C0h13DThwW7eTO9PhQG7fcWxzHudOtB7HGLooQZ2LyzVdR6uq6Ob6+hlxTCQRBmKEmQhU079ORpjpb6OkSlhXucEI4DfyiDeEFxaXkkxdqahSltKy/AIxL6uAZpoKqFGro0aDluo1WlArMVWd/UXChbFPoKTabMqNSSG4QmEKQYEijy+APF4/cvn82O7qwf32Hq69u4d6A238kLsVTnW2UU6w81Rho5+6wH6OLKWmZ22c1fFwZYQ55V43owsywpzR5ou/8E9WblDZAFQq8KhC5RWWsElpRTxnFfOs5dSorSAaVTnNsViJOcMKJn0WNes5atLzxKTnh4+eyL/4i8ZqjDMCyOMjyOUj2OMjIK1VDgwN4T7bEAoEz3BO7xnoGWzGoXA/cfv7FQO9/Sqq9odEwV+371X/uW+iOUmWI81Ql7UqV/4/YU3V/XI6dPuGz0TSV19sjpRjPpvj3JMTW51iR6M/MvX6zGuvymnNuzsjjggeGDh4OrFSnK+djUeShfQk26krXa8Gh0MNCoWaVpUtEvWKRcDxi8jCsmKxIKeEZpmLSa5FSfKsCpJtVp49p4nPntdkV9ojgGwukbM5RDTgEHGfrRu1dvdwJ9u6IRg6wrs9RxQHTxzBlPOEkN9dP3DMk/YKpUhARpgpAj5JzTLCTBLQM70ZKcbm6ZywUhfEivCKBYVYqygkGBfSeUVFxJpZTEyGYpothQwzSiHDzFKoMKpVK0CrUlDp3KYUb5Od20x9Nxg+U3n2qAgKhs6G4QoEBeT0urDD5UI2pwsPuTulHbC4ub2TCwpt4PO1qfefbneHQwGV2eKvb90WCXibeoXSSwJGmOllj3hLwwgz3ojO0vqij56g+WajoNSYEK8wCtnW4ZBhSMEXijnWImrWF1Gdtohkm7TEYh4OGSad2aTKc2HDZik+M0Yt6aiIcPbIiBSKCw+5AmjQGQSPt0dar+T6h3ogGGoFl6eN7x1qxWJwSHCEhvjjjUOgyxagFYR0ijKSzrjXrV8fiZFHPdqNkSnZDbX3yung5zYsldMk15rO6swp2ZDz/CSKcut7LbLyqle3nQ/Fdezk0/L/xxKKKxEAsvm7RKAa5zqHj6Fs3IirBgYQBNSFJMQVIUwLxQVlC0mWeRE16BaSigKTWJJnIgVZJiodOZHChrGjJ3G2xBSqk0JwhaVIIwLgngEv7hjw4rYeL3K4m7h+WxN3srWJUtKsDApnNM0tzekYimsKWqekCCPMlMAel0YZYcYFRlbJOQRQHQA6tnEjWnzSaRF4hQVhkkkqSkqJ1VSCtOoSsShnOGQYzTTlUoNWI4UNI3qNBpRKoFK4MKWCfRwlqztJBClIobhEirxSGC7p5w0ih7sfDQz1467Bfuz2tmO7sw2d6WhHlPRhIdRn6TvRl46huJIF23TbYYQ5XQRTV54RZuqwn60tD4cNu3vZVVq9QqWhQLVCQXY20muyiVJxNmSYUVcBalUFybVmEKvJTM1GMzFIIcP0iEqhw9iVHASkUFz+IAXpXKXd6cSDDhfqHXRhX6AFOb0tXJ+tRQrFBb5gD9832AsYeTR20evfN7NCcSUHzOm38rB12QK5lsBVtZFD7oE7rv2U/P/CxcuYJ5DpQz2pGrgTbSQy9fr7l7bJac2b53fAPti2c9ekKk1wZjbqSDDAiaz+R9YFBh9oDTyIhvCKxUtIhm4pVaqWiItK88TinHySJ4UMy8DEYuJopokRZiKNEVU3cvsouLyA3T6KuvoH+NaufnxSCsUVPIJsjiPKw2eOiBy2qYIh231deyKOo5Mk3pxrhhFmepqcEWZ62mXWSiWFDMt2e9QBBa8hyytLwGgsEVXKElJRUEhzLEXEbCiimSYDMRuM1Kg3gEbNUbWSp2olN7yLVg4bNmsRSrBi/xCKK0QgECRICsXl8XmRy+tFTq8X2R1duHewk2/p7qS+QBsecrVyJ9talSJyO9XE858zOBRXgtGNW/WMMOMGZVwrYoQZVzhZZRMhcD5kmJ33rVhmDit1mbxaaQ7nW0pBpyklakUpzbbkUbMxlxp1UugwFck0KanZoKLSkRM5bNhEDbG/j45AVCgu5HAL2OEWkNMTxg73ANjdA1yfbQCCwWbs8jaj3oFmCIds/JBvUHWixebQK0IabihYf+xYiMGbPASiHboLS7IjYcKEGz/xdVmK4C2XFctpatQlT7jZ2lKUo3TlGw2RGRXV8+8+I6us3df4mJy+r/fAQLpCwaZk09Uyk5QrOmQYWWCuIEhRCTxUkAWllTTXWkHNhkqxWAoZlq0dDhkmHT2Rw4ZNsi2W/RwC0aG4em0h3DcYxF0DITToaOO6Blu5E61tSBRPgD9wXHPyzIlgSBm0ZNqCszEU10zpE4wwU2ApRpgpAJ01OS4C0ec2g7kZuQqNOocAzaWVhcXEYiwBvbZYzM/KolZzNjEbsv4xZBgPoDgXNozhPD4Cw6G4xLPhuHyBMPIFQuDzS6NKO7Y57bjfbgentwP329v5Mz3tSBC6SCDcyR1p7TJpcfhEZ0iYjaG4Zkq3YYSZAksxwkwB6KzJcREYGTJMwAodoqCHgpw8olLkg0qVR3LNpdRkKCNqVRnNzTSSrMyzIcPUSjR8ZlPDNgpO2M2kh/9cOC5kd3nRgN3HDQ55kcffjlyedtRn74BwqJPzBDvwgK2ThpFL9PhcczUU14R4pkmGuvJ1NbIooavXbZHTgTtviIQSI/NL2IxcjPZCXednVVXP/PWgXEz1zkcRbJeU6V6W/z8RobhiFHVS2VgHmBRcMy/z5vnrrRAKWinGVmHJvCXUbFxCteolwoLSLFqWZxULsrOoQXc2ZJh0Z9f4CJw9MgLDR0a6+h1cW7cDN7U7kMd/nLM5j3Gn2o4jjnaBwHWzUFwzpzMxwoyvrRhhxhdPVluSEPjRgnUGFyVGRQgMQtWCUmrWl1K1slSsLCgQcyyFYDYW0AyDlhi1OtDrtKCRwoWpMFUrzx5DkXbSzvVLCsUVDFMIhSjyBPzI7fWDyxtAdmcP12fv5tq6eqg/1MY53a34dEcr5mAIiZydheKaOR2HEWZ8bcUIM754stqShMA3KzeoCjmX0k8VqmBpnpXXmyxEzVlpnqWcGDTlwyHDsjKzqCXDSqWQYRl6nmYYWMiwKPsgt48gt5cM3x0uOxpwDOG+ITv4A9IO2DO4b/AMBIMDnMfXj/sGBkI05FeJWhaKK0l9PN7NPJK9Okeu07d64X2Rqdrbr/5sJL1hbWakXT7iwjbeosyo+viGg5FQXKpnX39FFl7z3p7zobj6952ZUUqNEJYNH2ay9SYpuxQyTON0q0QFr/ZXFS1CWs1CwuFF4oKSElqUW0ysGSUkzyqFDFOSnEzl2XOa585rTrKt2ZQd2RwiHnSKaGBoOBQXbuvt4k62dkMofIR3+o4oGk8ewcB7QtTtZaG4Zr7lGWFOzYaMMKeGGyuVpghIIcN68kGh9oPCu6K0kKrVBUTBFUJ5YRHJyiymRl2xmGs1D4cNMxvMRKdRglYjhQ1TzrXpWSkUFwqEBAiGw2jI6UaSe7u+ITd2uDpQr72Da+7qwILQosvrPAAAIABJREFURh2+du2RM22hUDAIGRkBFoorTTv/JMRihDkJsKKyMsKcGm6sVJoiMDJkGEU6IygURiE3owh0qiKqUhWK+VlF1JpRKBp0RTQ7U0eyzTpqydBF1jLnwpompYClNUqnx48c7gAecvWgXlsv19HbQwPhNuQNtOKe/jYsikPYGR6CowccLBRXmnb6aYr1wsaNnFzF0VbvLXLaf+tV35fTwX+/6YJIM5IzkNl+yR6uAED11s5TsrqqX239lZzmTrX8Rk5v7t7nmy2QsCnZ2WLJSeohHUPZXFeHFh87hk51eQuFMCqgQAtDy+YthPzsBaJRt1CcX2Km5YUZYmG2eZgw5d8k25pR2c+9DPDAkBv32Dxcd78b9dvP4LbeM/zHR89QQpp5gTZDa3uzTesUa5tWCrfCVnFG6ciEjRkBRpijQMUIM+b+wzLOHgSGo59IpIle25/JobCFYj4zuKB0OcnQraBq1TJh2TyLuKDMQkrzLSC50pPWM6X7bL7OvQy4rn4nbul2cmc6ncjjO4L6Bo9wB04e4SjpBSL02vtO9GU2FYoA20g9QCTqwmyGZi7qxgiTEWY0AmyEORffAud1HibN+urrNEqO13ipVwvFhReBWn0RxXh1+KLFWeKy+VlkXlEWlXYCSq70pN9svaKcqXMtXUPc8dYh7nDTEAqH9yCPf4/6cPNeEYLuIKLuCxq0rqOwlW4GoAhAgpFdcwiBTVfc9rasrud3m6+S09RsmP0oSC4hz126u/7fTjltfX/vFXL6O527IjtmZxMgjDBnkzXjoMsDl99eSxC5FAGqDV96YY6wqipXXFSeA0oeqEIB0n3WXlGEiU+02BQHTg/yuxptlJIPFSJsy/hw34dOo1NcfGyxyKZhZ20viEkxRphnYWKEGVN3YZlmEwIvwEbuKBzlTIUmzn7x0lqiwJcghGvDq5dkCcvnZ5EFJVYqbWaY7SNMyajylOyZLgc+3uzkDzc5IBTejry+DzJffudDMaQIai3OAHOgPpuegMnrwgiTEebkew0rMSsQqIMqJWSBEoJIKdxyeS3Rqi+hPFdLVi4yC4vKMsWKokzA585kSvfZfkm7ZDv6PFxLtwefaveiQHA77hv6UPnHN7aDKuABAA87bznbO8E/67fFsrxA/l/3t/71TTkd+PZnls49NM5qrHx5W6+su+Gux6+R0w86Dh2YjZjMgbffbDRbfHX6SeEajdPl0igUvMZ3+ydrSYahlqoUtWJVuYnMKzGJZfmm+LaY/rXhHlsAd/cHcEdfALl8DXxHz4fqp19sQJQ6BISH6h0HHemvBZMwnggwwvxnNBlhxrOHsbpmBALfL682GZDOKIBgCn766nVilrkWdOp1pLRAJ5bkSTE055xXdjQwFMaDQyHcNxTGQ86PcGvPbuXL2z6iBHqxEvXU730j8mU9I4zMhJw2AowwGWGyEea0H6OZX4EU0YRTkixKFFbfp69YKxblrAOjfi3Jz1KS3EwVybGc9fQzhy7k9IjI7iJ4yCWiQcd+/kz7fuXbO/cDwq1IxC312/7cOofgYKoCQN2yK6+XgfA+/p2tcjq8Zumcez5k3bmmjkjf0D74y4jf3S2vPfvYbOw0jDBno1UnqVPdyivzIQz5gCE/9Okr1wjzStbQTOMaYjFhas3AJNM4yw9f/jNgyOMD5PGDdMc9g0e4k62Nivf3HKFATiiQ4vjmV/94YpIws+wzHAFGmP9sQEaYM7xTM/Enj8Cmy26rAIAKjKEieOWaleL8kpU0J3MFydBLMTIxNenn3IcVCpyNeSndcUffae54y2m+Yf9pDPQQEuhB/H+FhwDqof7sGUx2DnPy3W7GlWCEyQhzzr0IZ9xTmgSB77vpziWIkqVA6ZLw+uqF4sLyhaQweyHVqhHVaQC06rnXT8ICoLAAEBYAt3R3cEfPtCt3NbZTSvciSj4qPv7RXvO+ciI5L2CefpLQSdOgiftv/8ofI1Oyj33j3+Q0tWSkgXQpEkEQzk/J3vPE+/I/8radiOyYvavpzWCKpIt7s3PvRRh3CGd+hQ/c9rVVIhIuQoBXhdctLxWWVJSQ0vxSUCqAqpQg3efcJZ3HlDyaUArc6Y5+rvFUP//RkX6g0KAQxA+tO043qEz9pHvfp8R6qGeu8eZAB2GEOYqRGWHOgZ7PVIToyCXB9UsuRrzqYoToxeGLluSLVaUFpLQgnypkd3iz2LvPWH1BIsxzP661245PtA7xjU12EIQG5PF/qHrlvQZNSB3szOgL/bypadZ8QbNHY2wEGGEywmQjzDn6hpBiY57OCSt1QawIffqytaDTrKM8XiusWJAtLizNImUFWeedFcy5PT9ne4UcuaS9x8219Li4021u6g81cINDH2r/8E6DqA54dQDeu/savXO0G816teuyVuXKSga+fON5ZwX3/NuKWa/8JBVU/uXdLrmI9rtPRqZk64f2N06yqrTNzggzbU2TWMHqSterweFQg0KhDn56fS0y6muJgq8lSyszhAWlGaS8YA4vzPwj9rh7wI87+/y4vdcvOTHA3X0fqv7r1QaBUqcBYccPhvY5E2stVnuqEGCEGTvyjDBjx4rlnGEI/GjBOoPLS4wKHgyBW66ogezMGqJR14jlBXpSVqAjRTn6GaZSwsTF/UMh1GcL4T5bCDk8u3F7zy7Vyx9+hATSFwZl36NH/tqXsMZZxSlFgBFm7PAzwowdK5ZzhiFw78LLLdpQOFPA2BK89cp1pDCrhhr068SiLBXNz1aRXItqhqmUMHHRkFvEdqcIdqeIBx37uJbuj1Vv7PiYImjHAmqr37G1PWGNs4pTikDdgvWflAXw/uR7L8npcO0KdUoFS8PG8cnzvjz0D/z6u7KID7/13E/SUNwpicSmZKcE28wvVFe1PhfCkAsYcoO3b1grVhauo5mmtcSawZHsDEwtGbM48OXk7IfcXgC3D6Q77rUf4k+1HlK+s+cQJfQUx3On6t945tTkamS5ZwoCjDBjtxQjzNixYjlnGAKbLtlYBgBlGItloQ01FwgVxdUkO/MCyDAgYjZIzgrm6E6fUQzpDwDySY4MAsB19Z/kjrecVH6w/ySl9DCmtBG/9PvD5wJJS4WZE4MZ9iyMJy4jzNiNyQgzdqxYzhmGwL03fL4KU2ExJahKuHzVIjK/dDHJz1pE9VpE9RrJYUHqZx+kXaoo9WJIzgsgFB52ZMC1drdxR5vbFA0H2xCQvRRg7/LQ4N6jW7fSc6TJCHOGPQvjiXv/rV/8jfx336Pf/KKcJtmZqddSDnguSZIuz8k5VHTf++k7MkAljQ3Xyukv79sXTj1wU5cgDd5GUxeelZw6Ag9s/PdqAeMLMaXV4ZoV5eLieWWkJLd82FGBWnnWYUEqr3R6GRDpTCYBIMNODPq4xpN9il2H+yiQBoWIthcc3dFgLi8nEmkyrz+p7DTxb5sR5iQwlT4sGWFOAjCWNa0RqAPAPVDNLal04oGaDRcRjltNEawWLlpSKC4qLxRL8wtBwcOwwwLpl8xLIqVznnVQIEjAF6DIHyRUo8SgViOqUmDAGIDjALgkzxZHOTHAzd02/kSznTt02oYEsQH83u3KV99ugCANQRaE6o8dCyUTNtZWYhFghDkJfBlhTgIsljXtEfgSVCsWFip5p48oxJvWriUa1VqKuTXiBQtzhEWlOaS8IJsOkxKGYXJK5iWIAKIISBABDblEbHcJUmgtYtJzxKTnaYaBo5KLPonIk+2qb3iSVRplAuD2HhfX3OnkTra6IBBqQIOO7RnPvbM9oAEfAPg2d++T7uyawQg8mrsySxbffcdNEWcFvvu+UJ1qtZDDHRFB9fLfI+d/g1eviQR5p3kR8VMmrupPb0Z2juvvfSrixOBB+6GjKRMqDg2zKdk4gDhTqniyslJls1tUKmVI5bvhslrRoK8FnqsVl80zC1VlZrG80JwyXSRn56HwWWfn3QNhrnsgjDv7wiTPqhBzLAqSk6kAtQqoRgXSPVUX7uz34c4eH9fS7UMeXwPusX2o+f0rDRhEVxh0znr7R65UycbajQ8CjDCnjyMjzOljyGpIMQJ1Wev1oPPq1QKvd996RQ2xZNSCRlUjzCsykPICvViUa0iqiNIUjjSiFESKvP4gcvuCyOMNIqfbhgddNtRvs1GLyUwzjGZi1JmJUasBg15N9RoNKJVAlTwCpSKpH3243x7EPYMh1D0QRC7vLq6tb5fypW27KQ/9Goz77zvw5kBSMWSNxR0BRpjTh5QR5vQxZDWkGIHHimvMAiWZggKZw7d/cp1YkFVD9NoaUpSrJgXZapJnTe5hbCnepD9IpbiT2O504oEhF+q1ucAfbME+fzM36GghRkMR0aiKQa0sormZZmLNMFOz0UwMGgx6vbSjN6lzx8juELHNJeBBh4hszr24uXOv8s0dewmhnaCAjkc+fOV8CPoU25s1PzUE6strL49MyT7xvVfkdPjSat3UapxeKe5EWyQajup3L22Ta+P/tvs7clq8ePkmOR38/LXXyWnh4mUpmY7hjjZHlNbc/4tvyv945P3nn5oeGqktndSv89SqylrfXLE2G1M+hwLNDnzu2nVCecE6mmlcR7LNPLWaOZJlTupOH+T2UXB5Abt9FHX1D/AtXf34ZOsACoQOgcNzkGs8dQjmFS8S9foqUCkWiQtL80lZbh7JteRTSwYmFhNHM03JJUyXF5DTA0i699kP8KfaDvBv7TyAEG4SRKHph9u2NrGeNrMRYIQ5ffsxwpw+hqyGFCNw/2U3l+AwLeUQlAQ21FYLlUUXUmtGNck0Ypph5KjZkBjyido0g4IhgoJBAv4QQR6fF7t8XuRwe8Hu6MK9g538me5OFA43E6erGR1uaoaKkiLQ64pAqSwS5xUW0RxzETEbiojFaKRmo4EaDQZQK3mqUXNUreSGz6NhlLBzacgXAPD6Qbpz3QPH8bGW44pt+04AoUcwpkceeuWPR859hbLzmCnu71NtnhHmVJE7X44R5vQxZDWkGIHN192xkFCyiABaKHxi1WJhfvESkmddTA1aTPRaBAZtYmYcoo9lOD0CcrgF5PAIyOn5/9v7FuC2rvPM87gPvN8gSPAFPvQiLdmyXpYjKmrsxOskdhJn5ewkaZo63Uwnu9uZbdpknMRLyo7tzHRab9LNNu22TdNmtontNMnacWwnTvygKL9oWZIp6sEHSIIEAQIg3sB9nbNzSV1IthubkAEKtM+d4eAXdO5//vudA3y4557/+5dQKrMEY6klVJYnYS43BReWpoCkLWmFckI8G0lIoWYXsthdwATdNOgNQZupi5qEEAl4m4nb0UIdlhbqcQnE7RCp2yFQY4dvvVJPdAEDSVkRMkDh+TA3Nj3NDR+fhpSOAgJfPgeSo32r+Zg6YTLSvMJz/nK6/8btX6wsGxbu/tJ/MXyQoO9y3K39nEvSMoTHR1LGiaYfP/nPhm1+8cR9hv21xeOV5+Ur+xMuHHR7cyXm8m3vr9jybTe2V9rYzGuP63JaShezq6xffqCy05ifPXWr4e7I009fTNy8nD6uwDn1+YK8AhfCunx7BO76T3+8k2rqtQCincqBa3rVbT09pD3Qu7rzVFjdgVqP45LEfxRLyWgxIesbZ1AiPYMjsTA+OzMDNHUcl+Qzwunz45IsSF5PUvqTiQlpEBziQAhwoAA4sMnfS0XYAyDqVbd09NJWX4/msveS9mYLaWs2kxafBXAYUA4D/bUuh54rqukiBgTg87OL3MmJKDdyYhFQepQCOCzMnTp62u+nDz70EIGMMOsyBPV2ygizBggzwqwBiMzFuiOgixUAcAgBEEfyZz6wB/HcHgDBXuW67e3qtlAH6Qx2rIgV6LmNQg0fYV4gFZ1cYKmsgGJZQUVJAensMk5kUjCWXEa54gxaSs6i6flZpGgRKEnz4PhsxGlBypmIrP4dGFUOg8P4RjCFFkJ2DJpdzcAkNlMOBLTu9k7N5wxRm7mTBv0+4nU3UY/DR21mkVotArWYxLqQ56WqP1ORBBoPJ7hXzyWAph5FJfk5/slfHy2UiLKpjZc3ugzYuk/WBumQEWYNBoIRZg1AZC7WHYGVOzQQ5mwBB858+AP7NYG/HnB4v7p7WzPZ1t2sdQWbqaGeU8tlTH15Sc+tVBQAU9kiSmSKMJ4qwUJpFi1n51A8NYtkdQ4UinPcYnoOKEpWRFLGdv549rUJJ2kBo5ouM6eryd4ODqM+sATBIZcNAGSDQLSp7d4gtJiChOeDWrO7izgcIWoRu2jAayd+t516HXYqXrhzNtVQ5m9leVkfRgrQzGIaT8xm8Hg4DWR5GCfzw/y/PjUsm2nJD3HxTyPHSus+4KzDy0Lgfuf2Sg5y9gu3PW44KQ79572X5XCNJ8FYstLS9C+PvWb8g39s+F7DRrbCw4Zd7TLmkS03/J5xbvlD++4xbOmOW99n2FpP2xqjvbxm4j8/Wtkyaxn8PxVd2aHk6JnL83jlzmJLslcO+3XpeRD0CbYAx6tlKhRu/+CAarIchDweUHZu9pCruj1aT3t9VKTLMoCSBEBZBnh+KQPDC1luaj4DsoVxnMyMo/GpcUJhhOPVCDCVI9UuYw71fKgJiYqfaqhJvaqnX3Nat1OruV/b0uEjoVYvafXrd5uAWi1Af63HgeZiBTQTzeOpSAHmy8NwKfmc6Z8eG1aAmnNAW/ariaMXZVnqEQDzWTMEGGHWDMo3OWKEWT9smecaI/BngR1WD8QWCYhW+fYbBojXMQBEcUDbGrJrPa0O0tlSO7ECRaUrVT1klYJ8sYxyxTLMF0swmVlE8WQUzyxGaVGaQanMNJ4Iz2DKJSWiJid6balqN8oM9t7s4KnmJKLiUHu7Q5rL1qVZhBANtbbSZm8r9TpbicNqIXarBTisZirqmrQ8pAKPalXZAcVSZTQfl9DCUlkXMUCR2Ij4b789BjFKAElODJ17OlHj4WTu6oQAI8w6AQsAYIRZP2yZ5xojMBi6xsVLFidBqqv82Y8cUFv8A9BuOaB2NJtJe8BMgv7a3X4VShQWigTlSxSmsmmYSC/DaCKNSvIkzOYmYTQ1iSU5RvOlOIgmYzwhpbwilf7i5JPFalMxvtN7s5gEQIRUM0mb/T5kt/kgJ/hI0N1DbLZeahZ6SLPPS31OL3HafUDXpHXZMHVYV3cD1aAcEkqkVaj/LS1rKJV7AYfnX+AeOfoipNo84ejCvccena/xcDJ3dUJgqP36g4brwre//Khhyzfuq90PygtOuZcvCvSL33/kMaMv4bGROw27HsuVg76dQcO/NnDtkGGXP/ORTxm2cuNuRwXiGulJ45PnKy6td363UiLtnuce/vs6DWfd3LIl2bpB2xiO72we8FtExacR5Jc+99EDWk/wAHXZD5BmL0f8Hl2jtWY7feByjqDlDIGpLEHRRBTNLC7i8ekokpRTdDl7in/l7Kl6LFf+97b95qZc3lTmOTO4elOfZrb0Ax73a1u72rX2QDtp8raTZg9Pm9wcaXLzFbJ8h6S5ImCQzq0KGcSXR/nzsy/xjw6PQgCmCYRT33z2oenGmAUsirdDgBHmKkKMMN96pjDCfLtP0gb//68f/Fg7kmkHQLhd/vD1e0hP+x7qd+8mHgdeUcpxO6rPv7gkrxKWFQ2WJQ2UJQ2m83mYzuVgOptDy7k5vJiYAxPzEVhWwjBfDIPRUzOcYillHaD0QA03xOjPaYEfCCYZ8+XdV7VrFr4DYKGd9LbqZNlBHLYO2uR2Ea/dRV12FzWLPDWLutgBt1KVRRc6uIxf01AXMMiXVoQM0MLSGD4THuOfemkMQnpaw/j0/T///jjLxdwYHyBGmIww1zJTGWGuBaUN3ObOD39uM6J0CwRks3rD3u3qps4dJODZTp02SOxWBBzW6ueAnotICIAa1e+wZJjOyiiZUWC2sAhT2UUUSy5CWZqGufI0t5CcprKaIvlSynFyJrVoIqojIipHQO2SlvXUkz4whrNtTuzobXPKdquLQ9BJAr4OYrN2ApHvIAFXG3E52ojd3AZ8bhPxOszU4zSt5mxyl5W3CfWt8yubm2R9x+wUPj01yT33yhSg4BUM8OjdD/7vV+DqXSwTMGjwz9DXP/mFvzRCLN79pYpGK2kPXHbkK6pQFw7h508vVOyHf/09w8aj09827PWsdDPYd7iydZw6td83YpBued9XKvan/8Nmw6aeSvWwqvG4FAfLnz3wiOGA7/F9vHLtR45U9HKr7mAdT6j+y3Idg2NdvXME7vrEHVdrGF0NKb1aGdi1WesLbSatgc3UYgLALIKV12qPlbqVegK/BlA0UdI3vaBIrIRS2Uk4H5/CZ8OTkNDzQJLOo9PR85fmVVbbVbXtB8EgAoeeQSDuR5qddGJIOykEneq2zi3E795KndYtWlfQTjpabKTVb9dra67moPLVdnWhfucqDngisoBOnovyIycWKKUjCHHDXLd7ZGhoiDLSrB7a9T6DEeYq4oww33rmMcJc70/mOvSnixX0g8NwGUyh2c/s3QUwtxsAulu+/upObWt3iHQ2h1aIQqyCKC4t8Fwsy6BQlmGhKMPlXAIl00soupSAudIMTqRm4GRkFlISRSU16gxHo5lIRusH/drt4CGt3pdfyds8tASVnMfPc9APMfHJvW0h6nV1ErMQou3NAa3J0ww8jgCxm03AbhWpxWzShRsox8GVItVrOS6500bTkSU8Ph3Hr5xdQpp2FCnaMH7q2RFnGSlnArL6d6OjylpcsjZXBgFGmIww1zLzGGGuBaUN1uZBcBgvguNcKujE6k37ryO8sJ8ifJ26p79F29YVJN2tLStLkbpQgS5asJZDWl16BJIuRJDJo6V0DsWW87BYCsNMLoxiiTCU1AVQLs7zsfQ8UOS8VOZzqeGz+RtBNxkDK/qq67HsAvX1zyEwCMGh0xalJFkRFS1aq6cZW80BasbNWouvmzisPdRi6qYBj5P63S7qdTqJ2QSB1QSo/rqW45JnuXgmuozPzy3j05PLoKweBbn8sP1HvxpGFrlcRt7SkfDTF9fn1uKbtak7At9y76qsM2Y+d1NF77R4z5f2X27nKFxZeQXi9x95wfAjPP7sXYZ95PTTvzZsCFema8Mcg/491xjByLceuL9i33HrBw1b3b5pjV8ab74s0z/87Jzxru2+v/+oYd+19OrFrbQNg8abA1nbF0MDXwAL7c0I/C3YxUeDgDeVAJ//+PsHNCs/ADAe0HZt8yr9vV6yqd1bLW76BhdQLAP9Fc3HUyi8mMTnZlKgUBzDqcwpPHZ+DGIuBogWHxr7bUz330hfBoOua1zAZHIBTXOp127dTn227dRk2k62hgIk1BIgQX+AuuyQOGxQf75bLT54bjEHp+fz3Pm5HCyWh2EiPWz54aPDiOK8DEu5I0un89X6ZO3riwAjzDfjywjzredc1V8M9Z3CzHstEBgK7rIIEJtJiVpKn7nhgOZxHgSicEDd2uUkve0OLdSytif4kkyhpNCVklz5YgnkCkWYyetCBAtoMTWPZxbmYVkOo+XMNB47H1YRn+FEkhk6/ttMI5GljumlAg7aNb0h4rKFgEkIad3BdtDsbyNuRxt1223EYbNRh81KTbrQgaCXDEMA6OXC3jp3Ey0mSmg+XkaReAlliyN4PjbC//SpYxzgk0VKUvefeeqiBlotBpn5eMcIMMJkhFntJGKEWS1iG6D9oGefQwXEiQTZoX72tgNaq3eAWkwDpCto0dqbLbS1yfK2l0EpgLkCgdmCBjN5AtO5JEqkk2AxkURlZRJmcpNoMT0J5PISKJSWwMzCkkOE5VJSlRpx+VG/6z4fUASrhHjt2i1e6rB5qSh4QYu7W7PbuoGJ66ZNvibicTYRl62Juuw8dTs46rTxq/U1L6Sf/A7gUCKtwKVlFcVTClrOvoCmF54XfvrsCxCrUQWA6H2jT0TfFnPWYF0RuKtpZ2XptfTdr/3C6Fy5aX9FV/Z3BqQvx184+GdGC4Yt/OCRhwzb8tuT/8Owv5F6aW5dL64GnQ227a/IZmrbey7unv3Uh+4w3MsfOeCvdCW+vWYzd+Js5bGM5cvf+UPj3Hte/HmlhFkNQq+bC0aYdYP2yjm+s3WvV5AkL0HIq/zRbQfU7rYB4LQdIM0+gbZ4edLkeeuZfeHLAC0tr6rY6K+xZATPROfQ+HQEyuoYLMqvmY5PjCEFFmW7VhpaGC1euSuurufBvj4BLDUJQJQE0tO2hZq4rQDhLdrWUJfWFghRr7NLC/pFGvSLJOARV3I0jTqbv6MrmMlTuJwFKJOjML78End29iX+Z8+8BCiZITwfvnfk32aqi5K1rjcCjDDfGmFGmG/GhxFmvT+VV8D/V/bd3MYDrg0D0CrfemiP1tW6l3gde6nPhanXyRGP8/XbQPWaIPqOT/2uslxWYVFWQUlSYSaXQalMBiaWMzCdn0Wx5CyamJuDijqLSvKs+YWpWSzycjGxLB0BF+W+rsAlV9Xl62ps7ggEKYdbVQhb6aaODs3v7gROawdp8nipz+UhTpsXWC260IFArWa+slHqDZVdYL6oixjoGroARxOn8Jnwa/yvnn+NAnCGJ/z40JP/tOEqM1QF6gZszAiTEWa105YRZrWIbYD2gzd9tpdSukkDdJP6wX07tE0dV5OAdwd1WBF12pD++rrLuDRlZDlbhslMGSbSEsoV51E6O49jqXkqSzM0W5zBi6kZIstpIaul4fT5NF0oqeuVMlIr6Cs1QvviSG7ZbceYOrAJ2hW/p51azG1AENq0JlcncDk6qNXUqfndVur3WKjHYa3UDX1D3iYs6yIGEtCf+aJwdBKfnpzgnzk+AQF9FULulbsf/ptXG+25bq3w3Kh+vvGJL3zLiL1w9x9/1bBJZ8u/e0m6DKJxCP/6xKRhmx59uiJ6AOfS3zfeb8RHE5c7VoODg5XvDPjoi7cafko3Xjdo2NLnb63ssKWtF1dqL+1zRRnrwmH98gM/NewF5a2JAAAM1UlEQVRv/t/vftKwG/lzwgjzcmdQA59318e+uJ0gdQcEcLty8Nqt6rbQFtLatHVFpMBqfrNYgV63UlZW6lei+aU8nI0WcDiah5n8OS6eOIvPhs8BAsKIaNM0mgsHvTnt16Pd5KF1yKtcB5ghpRQMDQ1B8PiLQaDhIKRaUNkS6iMeVz+xmvrIpg6XFgq6SGuTa0XswSyuiD688UcH1H94qBrAk3Pz+MTEPH/01XkK6DEB80cH/+Xbx/T2jfxlsA5YN1QXjDDXPhyMMFexYoS59jnT0C0vLbSsfnrrtRDgXRTBXfL1O7rItq4uraO5C4jCqliB/nB+pbizCoBGKCyUJJgrSnpJLpjKxlE8FUORWBwVS2GczIbx1MwMUcgSASTeIUfjC6N2CsDTZJ3yKtcD9xXS/Nq+2zyCWnRjDN1Sd0eIOJ1dwMKHtM7WFi3gCQKPq4XaLWaqlwuzW0xA0MuFcVB/BZohF0gAmpqPc+NTMTw6HkMaHYGSfBQ/cnwEWIEKwkCtpSzgeoDzbu2DEebaR5YRJiPMtc+WDdBS11O9EUyhhZAdaweuuk4T+OsgBNcp+7YHtf7uVtLdqj+rWxUq4DBY0Xcsy1R/RalsBi4tZ1AskYVFaQqkc1NwMTkFFWmRKyhRGllcxAJfsChS4eWjYrFvVYRA3ybYUEnX73CY4F/tP2zKgKxZLfJmrsvn16yWJoL5JhL09VC7pZdYxB4a8Lmp3+2mbruH2i2Q2q2I2sxIf/4L9GfBlAIcXkihc7Mp/rWJFFCUYZArHvX85PFhTeYlizdT/pOJCekdxspOv0wEBv2HbMap8n/c+7hhF7/1395XcXlJFRtuPFzZ1Sn8w89+Y7ThfjnyNcO+Z27kpcsMZ8Ofdk/Trh7jIko37Luvgu3nb6ks2yr7t/+7+pum7z2sFydYOWz3/uNHDPuuzMmGrfLD7jA3/JRdvYBLN7Iot1wzQDn+IMBwQN3T79N29Hq1TR2+lYYXvgxgrkj1slQoV6RoPh6H4YU4PhOOg5L0Gl7OnoQnzusbVlKY0uUjkWOpdwlMa76MQX+fTYB2KwGqTdm55SrVatkBROEqbWtXkHY2B0mLL6hXeyE+F6Ke11d8QbPRLJ6cz+Gz4SwoScNcMv2c6Qe/GNY0ULBaQeHPYycraQhrDog1rAkCjDBrAmPFCSPM2uLJvK0TAoOhQyZpWTXb+ZKp8KmbBjSn9SAUuAG1v1sXK3BpXUGnLkAAyjKB+l++WICZfAGl8wWYykbQYiKCpiMRUJTCIFecRifOhzFWCqBgzR9Zevo9p1Kj4wnSaZMgiKK8s6dTMZtCQOQ6aU97u9bsb6cuezv1OBzU67ATu9VBzSZMzQIHTCJGC0slHE0U4exiCRaKR7n55FHTw78Z0ZCybJLA8p2zw8vrNC1YN29AgBFmbacEI8za4sm8rRMCX/G9z24GRbsGsF39g5sHaMA7QCxmXazASjqaraS1yQqzORWl8ypM5xWQyS3hVDYOY6klWJKmYK4wBRcSk1BWkjBXTOLx6SSQRBn44/KR0xsnZaRWcF+8Y49z6rYdbs4luAkW3VqLtws4zCEiCCEa8LYQr6OF2C0t1OMUiccpUJddhKmMApNpBScyujj98yi8cIz/2VPPQxXFNKgu3vfaUyvSgexYfwQGfTt3G70WvvOVin6sctP+1RUYAIDwy6MVVSbhwV/9wHiff/lURVt1aGE0sf7RN3aPfxHYYTUizPRt+5Jhy594/381bOmTN3YYNj43UynGYP3z//lZ4/17Xv7Fjxr1StmSbKOOTJVx3e/c7i6IggcT4pb+6LYBLdQ8QB22AdLiE2mzTyBNbhHFkjJaTEloIa7XrwyDudgMd24mDBXtDFXK4/zpqTNm2SRFXDH5r9lztsoI6OTp7Y1gKWfh8ps39WgQ9gKMe8jWzl6txdNLXY5eraPFQtqaLKTFb4H5Il1Z8s4VKFpafhFPRp4XfvLUiwCQOQKF2Xtf+vmGU32pcjo2bHNGmPUbGkaY9cOWea4xAoM7bw2qvBqEBAbVWw7u1UKt+4jbvg+YRUrNAgAmE4XpXAqmMikUT6ZgujgLE8szeGp+FmraPJCkefurkUg9CjzX+FLX3Z2etxkEu7DUm0Gxph3NSITNFPAB0tvaSbyOTmq3dJKWJj/1u5uIy+6nkAqQQgFAKqDF5El8PnKS/82LJykE5ziNnD3y1I8rFRvW/WLe4x0ywqzfBGCEWT9smecaIzB4w6e7FUx7EAXdyu/t3qn1tl9D/a5rQFmWYFkur/wVirNwOTeLY8k5oKpztFCe42KJOarArJYvZvPR41nPRJv2LksZecdI6yk7QyspWIeQ+Ua/NUeADVJgIy3+ILZZWojAB7UmTxdxWbuI2dxFXTY7ddrs1G6xo4XEeX5i5hz3/Nh5CsAJBOir9/z0H0+846CYg8tC4Osf+8Mjxomlr99R0XoV/t9zp4z3xSeGv2nY/SHrTwz79ofqX8/1si6qwU/65qYPHDRCzH9o772V5dnPf/SAYVv/8ocPGvY3f/S9TzXqJbEl2UYdmSrjuuuWP+jXMO6HlPYrA9f0kU2dfaTF24fiqQyaX8qguXgG5ovjOJE6jc+GxyGAEY6n85tbrZGxvj46dOQIhe+uNJEqEay++X29A34Nij4IiF/q67pK8zq2E7N4lba500dCzT4S9PtwJD6Hzs1EhONn9WXY5ymFx+798d88X31v7IxaIMAIsxYoVueDEWZ1eLHWdULAuPPpB4fhiU/ad1KKroUQ7tS2drbQtkBQC7iDKFuIwkQmiqPJKNCLPaczYXFyPgyJmtIon6QfvTZ1gSz1KN9NeZV1Qv2i28Hemx0AlBwc5OzSlrYu6nGGiMh3aV0trbTZ00bczlYcS+XQQiyHZ+NZQMkxKsnHhGdfPpZcyGgDYKd6+7tDLanuWNeqA0aYtUJy7X4YYa4dK9ayjghcqolK+q7fRyG6jiK0j3ocFuJx6Io0FliWJ2G+OAmXUpOcosZooRgn89G4FVqLsqaWBkcfKV1YZmBkWeVYfaf3ZjEJgCiCvFgMhXzQJfqIKPpIwNND7NZeYBZ6YKGMYL6EYLGEgaqO0II0Iv7ixRGzaJIiiZj814CJGFQJe9XN/6ptv9k4KTWw8wnDpghUdrqanhi+03j/rsTJs1V3wk5YEwL3+nZVhHqLB68eMk4irYE9hi388MmPG/aR5dHZNTlep0ZsSXadgK5HNw+Cw3isbww7s06cuW77gMrh90MIBwAEEgVA1l9RWTpFc4VT4iunT6kA5yygmPtq4uxFFel6BPYe9KnnbZqWk2bCCyZp56Y+ahL7CY/7qcXsARaTm4qCB0jyCJcvD6NfPj8CVVAEdlDcSGXRNuqwMsJsnJFjhNk4Y/Gei8TIFWwqAC52bXAP4QU9x2wP5NAy4XCa8igNZTmM0vkwOjExY1LUUtxuKz8QOXaxZMB7DrX6XPAg6BNsAY5Xy1Qo776qnVqFdg3jdmDimygnNFEONQFJPYlzuVdNR8dPbMQ6ovVBrv5eGWHWH+O19sAIc61IsXY1R+Bvd+3iQRTwC4ImEF9HP+BRP8C4n3J4gfLcAm+zzGuavEzy+ZTj5Fhq0eRRHRFRYeLfNR8KoGv59oExDEJNCIT8Ls1hd0JIXQTAIKC0Vf+DijYBC/kJNDY5KSqmksmJi3/KfrzUfjDe4PG+1r1e462y2fxFw7am1f9l2F9NHGWrLnUfidd3MNh3uFLIXuMyv2/8r2k+VtH4/UbyxPw6h/WW3bEl2UYajSpjGezrEyxxt6iJiqCK5m4V0m4AYTcAYIJT6IRY0CZ4E1EzjCSrRPadNR8EgwgcegaBuB9pQroTaKgTQNqJCFmkpfKimM4tKopacjocJUaY7wzrtZzNCHMtKK1/G0aY64/5e7pHY0nWkld42UWbNMoFCIABCsEiVeiiR1MWM5GMttEKPG/0Qa2UWju0BJWY6AdY9SOEfVhR00CV0yC2nAYilcESkI+A957s4HqPLyPM9UZ8bf0xwlwbTqxVjRC4dJcsyDptqshbeYyslIA8UEEehEG+H/jpYfAQYTmWNQJ9bW6gvuV4CAxC0PeMRUHYihC2EAWWSaFQbiJamf2QWRuQrBVDoJEQYEuyjTQaLBaGAEOAIcAQaFgEGGE27NCwwBgCDAGGAEOgkRBghNlIo8FiYQgwBBgCDIGGRYARZsMODQuMIcAQYAgwBBoJAUaYjTQaLBaGAEOAIcAQaFgEGGE27NCwwBgCDAGGAEOgkRBghNlIo8FiYQgwBBgCDIGGRYARZsMODQuMIcAQYAgwBBoJAUaYjTQaLBaGAEOAIcAQaFgEGGE27NCwwBgCDAGGAEOgkRBghNlIo8FiYQgwBBgCDIGGReD/A470Rd8v0U3QAAAAAElFTkSuQmCC)



 第一个图像以其自然大小绘制，第二个图像缩放为3倍并启用了图像平滑，而第三个图像缩放为3倍但禁用了图像平滑。

**imageSmoothingQuality**

使用[`imageSmoothingQuality`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/imageSmoothingQuality)属性来调整平滑质量

```js
ctx.imageSmoothingQuality = value
value = ctx.imageSmoothingQuality
//value
//"low","medium","high"
```

**image-rendering**

[CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) 属性 **`image-rendering`** 用于设置图像缩放算法。

```
/* 专有属性值 */
image-rendering: auto;
image-rendering: crisp-edges;
image-rendering: pixelated;

/* 全局属性值 */
image-rendering: inherit;
image-rendering: initial;
image-rendering: unset;
```

https://developer.mozilla.org/zh-CN/docs/Web/CSS/image-rendering

#### 保存图片

**`HTMLCanvasElement.toDataURL()`**获取**canvas**对应的data-URL

#### 性能

- 避免浮点数的坐标点，用整数取而代之
- 在离屏canvas中缓存图片的不同尺寸，而不要用[`drawImage()`](https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage)去缩放它们。

### 变形

#### translate(x, y)

#### rotate(angle)

#### scale(x, y)

如果比1小，会缩小图形， 如果比1大会放大图形

如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用`translate(0,canvas.height); scale(1,-1);` 以y轴作为对称轴镜像反转

#### transform(a, b, c, d, e, f)

a (m11)
水平方向的缩放
b(m12)
竖直方向的倾斜偏移
c(m21)
水平方向的倾斜偏移
d(m22)
竖直方向的缩放
e(dx)
水平方向的移动
f(dy)
竖直方向的移动

### 组合

绘制顺序：**globalCompositeOperation**，这个属性设定了在画新图形时采用的遮盖策略

### save&&restore

- save()
  保存画布(canvas)的所有状态
- restore()
  save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。

Canvas状态存储在栈中，每当`save()`方法被调用后，当前的状态就被推送到栈中保存。每一次调用 `restore` 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。

## 第三方

- 将DOM转化成canvas对象

  http://html2canvas.hertzen.com/dist/html2canvas.min.js

- 将canvas生成照片

  HTTP://github.com/randreucetti/canvas2image

## Tips

- JS的鼠标监听：mouseup（鼠标抬起）,使用css禁止选中

  ```
  -webkit-user-select: none;
  -moz-user-select: none;
  -o-user-select: none;
  user-select: none;         
  ```


# jquery

## 核心

- $([selector,[context]])

  $()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个  context 中查找。

  ##### jQuery 代码:

  ```js
  $("input:radio", document.forms[0]);
  //在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。
  ```

- ```js
  //DOM文档载入完成后执行的函数
  $(function(){
    // 文档就绪
  });
  ```

- ## this

```js
当你用的是jquery时，就用$(this)，如果是JS，就用this
jquery对象$(this)[0]等同于JS里的元素this
console.log($(this)[0]==this) //true

JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了
$(this).get(0)与$(this)[0]等价。
console.log($(this)[0]==$(this).get(0)) //true
```

- each(callback),每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素


```
$("img").each(function(i){
   this.src = "test" + i + ".jpg";
 });
//this是js的this
```

- size()/length当前匹配的元素个数

- get(index)取得其中一个匹配的元素

  ##### HTML 代码:

  ```
  <img src="test1.jpg"/> <img src="test2.jpg"/>
  ```

  ##### jQuery 代码:

  ```
  $("img").get(0);
  ```

- index(一个DOM选择器/ jQuery 选择器)

  搜索匹配的元素，并返回相应元素的索引值，从0开始计数。

```html
<ul>
  <li id="foo">foo</li>
  <li id="bar">bar</li>
  <li id="baz">baz</li>
</ul>
$('li').index(document.getElementById('bar')); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置
$('#bar').index('li'); //1，传递一个选择器，返回#bar在所有li中的索引位置
$('#bar').index(); //1，不传递参数，返回这个元素在同辈中的索引位置。
```

## 属性

- attr(name|key,value)返回或设置被选元素的属性值。removeAttr

  ```js
  $("img").attr({ src: "test.jpg", alt: "Test Image" });//为所有图像设置src和alt属性。
  $("img").attr("src","test.jpg");//为所有图像设置src属性。
  ```

- removeAttr(name)从每一个匹配的元素中删除一个属性

  ```js
  $("img").removeAttr("src");
  //将文档中图像的src属性删除
  ```

- addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass

  ```js
  $('ul li:last').addClass(function(index,class) {
    return 'item-' + $(this).index();
  });//给li加上不同的class
  ```

- toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。

  ```js
    var count = 0;
    $("p").click(function(){
        $(this).toggleClass("highlight", count++ % 3 == 0);
    });//每点击三下加上一次 'highlight' 类
  ```

- html()

  ```js
  //返回p元素的内容。取得第一个匹配元素的html内容。
  $('p').html();
  //设置所有 p 元素的内容
  $("p").html("Hello <b>world</b>!");
  ```

- text()

  ```js
  //返回p元素的文本内容。
  $('p').text();
  //设置所有 p 元素的文本内容
  $("p").text("Hello world!");
  ```

- val()

## css

- css

  ```js
  //取得第一个段落的color样式属性的值。
  $("p").css("color");
  //将所有段落的字体颜色设为红色并且背景为蓝色。
  $("p").css({ "color": "#ff0011", "background": "blue" });
  //将所有段落字体设为红色
  $("p").css("color","red");
  ```

- height()

  ```js
  //获取第一段的高
  $("p").height();
  //把所有段落的高设为 20:
  $("p").height(20);
  //以 10 像素的幅度增加 p 元素的高度
   $("button").click(function(){
      $("p").height(function(n,c){
       //n,c索引位置和元素旧的高度值
      return c+10;
      });
    });
  ```

## 选择器

### 层级

- prev + next匹配所有紧接在 prev 元素后的 next 元素

  ```js
  //匹配所有跟在 label 后面的 input 元素
  <form>
    <label>Name:</label>
    <input name="name" />
    <fieldset>
        <label>Newsletter:</label>
        <input name="newsletter" />
   </fieldset>
  </form>
  <input name="none" />
      
  $("label + input")
  [ <input name="name" />, <input name="newsletter" /> ]
  ```

- prev ~ siblings匹配 prev 元素之后的所有 siblings 元素

  ```js
  <form>
    <label>Name:</label>
    <input name="name" />
    <fieldset>
        <label>Newsletter:</label>
        <input name="newsletter" />
   </fieldset>
  </form>
  <input name="none" />
  
  $("form ~ input")
  [ <input name="none" /> ]
  ```

### 基本

- :first获取第一个元素-->last

  ```js
  $('li:first');
  ```

- :not去除所有与给定选择器匹配的元素

  ```js
  //查找所有未选中的 input 元素
  <input name="apple" />
  <input name="flower" checked="checked" />
  $("input:not(:checked)")
  ```

- :even()匹配所有索引值为偶数的元素，从 0 开始计数-->:odd()

- :eq()匹配一个给定索引值的元素,从 0 开始计数

- :gt()匹配所有大于给定索引值的元素,从 0 开始计数-->:It()

### 可见性

### 属性

### 子元素

### 表单

## 文档处理

### 内部插入

- append()向每个匹配的元素内部追加内容。

- appendTo()把所有匹配的元素追加到另一个指定的元素元素集合中。

  ```js
  <p>I would like to say: </p>
  <div></div><div></div>
  $("p").appendTo("div");
  <div><p>I would like to say: </p></div>
  <div><p>I would like to say: </p></div>
  ```

- prepend()向每个匹配的元素内部前置内容。-->prependTo()

### 外部插入

- after()在每个匹配的元素之后插入内容。-->before
- insertAfter-->insertBefore

### 替换

- replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。

### 删除

- empty()删除匹配的元素集合中所有的子节点。
- remove()从DOM中删除所有匹配的元素。

## 筛选

is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。

map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，

```
$("p").append( $("input").map(function(){
  return $(this).val();
}).get().join(", ") );get()jQuery转DOM对象

$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。
$.map( [0,1,2], function(n){
  return n + 4;
});
```

children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式

find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$("p span")相同。

next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。

nextAll(expr),查找当前元素之后所有的同辈元素。

prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。

siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。

## 事件

```
1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。

**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。
**data:**作为event.data属性值传递给事件对象的额外数据对象
**fn:**每当事件触发时执行的函数。

2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 
3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。
事件委托即事件冒泡
// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp
$(document.body).on("click", "p", handler);
e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡
```

trigger(type,[data])在每一个匹配的元素上触发某类事件。

hover([over,]out)

over:鼠标移到元素上要触发的函数

out:鼠标移出元素要触发的函数

toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。

```
$("td").toggle(
  function () {
    $(this).addClass("selected");
  },
  function () {
    $(this).removeClass("selected");
  }
);//对表格的切换一个类
$('td).toggle();//对表格切换显示/隐藏
```

change([data],fn)当元素的值发生改变时，会发生 change 事件。

unload([[data],fn])在当用户离开页面时，会发生 unload 事件。

会发出 unload 事件：

- 点击某个离开页面的链接  
- 在地址栏中键入了新的 URL  
- 使用前进或后退按钮  
- 关闭浏览器  
- 重新加载页面 

# ES6

## 模块化

### CommonJS

是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。

核心思想
允许模块通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或 `module.exports` 来导出需要暴露的接口。

**优点：**服务器端模块重用，NPM中模块包多，有将近20万个。

**缺点：**加载模块是同步的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

**实现**：

- 服务器端的 [Node.js](http://www.nodejs.org/)
- [Browserify](http://browserify.org/)，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大
- [modules-webmake](https://github.com/medikoo/modules-webmake)，类似Browserify，还不如 Browserify 灵活
- [wreq](https://github.com/substack/wreq)，Browserify 的前身

### **AMD**

鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。

**其核心接口是**：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块**提前执行**，**依赖前置**。

```js
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ... */ });
```

**优点：**在浏览器环境中异步加载模块；并行加载多个模块；

**缺点：**开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；

### **CMD**

Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。

```text
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```

**优点：依赖就近，延迟执行**（对于依赖的模块延迟执行，即只在需要用到某个模块的时候再require） 可以很容易在 Node.js 中运行；
**缺点：**依赖 SPM 打包，模块的加载逻辑偏重；
**实现：Sea.js** ；coolie

### **ES6**

ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。[ES6 模块](http://es6.ruanyifeng.com/#docs/module)的设计思想，是尽量的静态化，使得**编译**时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。**但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require**。

```js
import "jquery";
export function doStuff() {}
module "localModule" {}
```

优点：

- 容易进行静态分析
- 面向未来的 ECMAScript 标准

缺点：

- 原生浏览器端还没有实现该标准
- 全新的命令字，新版的 Node.js才支持

### commonjs和ES6的区别

- **CommonJS**的`require`语法是同步的，所以就导致了**CommonJS**模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ；

- CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用；

  ```js
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    counter: counter,
    incCounter: incCounter,
  };
  //commonjs
  var mod = require('./lib');
  console.log(mod.counter);  // 3
  mod.incCounter();
  console.log(mod.counter); // 3
  //ES6
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```

  

- CommonJS 模块是运行时加载，Module被加载的时候执行，加载后缓存（只加载一次，第二次就直接用放到内存中的结果，不重复加载了，第一次加载的时候会执行）。ES6 模块是编译时输出接口,使得对JS的模块进行静态分析成为了可能

- `this`关键词，在ES6模块顶层，`this`指向`undefined`；而CommonJS模块的顶层的`this`指向当前模块

## 异步操作

### 背景:

**js语言执行环境是单线程**

JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，**单个脚本**只能在一个线程上运行（称为主线程），其他线程都是在后台配合。

JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。

如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“**事件循环**”机制（Event Loop）。

为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。

```
JS中的异步操作：
1、定时器都是异步操作
2、事件绑定都是异步操作
3、AJAX中一般我们都采取异步操作（也可以同步）
4、回调函数可以理解为异步（不是严谨的异步操作）
剩下的都是同步处理
```

**同步任务和异步任务**

同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。

异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。

### 1:回调函数

一个函数作为参数传递到另一个函数中

```js
function f1(callback){
	setTimeout(function(){
	callback()//f1的任务
	},1000)
}
f1(f2);
```

优缺点:简单,容易部署,但不利于代码的阅读和维护,各部分之间高度耦合

**注意:回调并不一定是异步**

### 2.事件监听

异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生

监听函数:on,bind,listen,addEventListener

监听方法:onclick...

### 3发布/订阅

事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](https://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。

首先，`f2`向信号中心`jQuery`订阅`done`信号。

```
jQuery.subscribe('done', f2);
```

然后，`f1`进行如下改写。

```
function f1() {
  setTimeout(function () {
    // ...
    jQuery.publish('done');
  }, 1000);
}
```

上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。

`f2`完成执行后，可以取消订阅（unsubscribe）。

```
jQuery.unsubscribe('done', f2);	
```

### 4.promise

- **名称**
   译为“承诺”，这也就表达了将来会执行的操作，代表异步操作；

- **状态**
   一共有三种状态，分别为`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。

- **特点**
   (1)只有异步操作可以决定当前处于的状态，并且任何其他操作无法改变这个状态；
   (2)一旦状态改变，就不会在变。状态改变的过程只可能是：从`pending`变为`fulfilled`和从`pending`变为`rejected`。如果状态发生上述变化后，此时状态就不会在改变了，这时就称为`resolved`（已定型）

- **基本用法**

  Promise 对象是由关键字 new 及其构造函数来创建的。

  ```js
  const promise = new Promise((resolve, reject) => {
      // do something here ...
      if (success) {
          resolve(value); // fulfilled
      } else {
          reject(error); // rejected
      }
  });
  ```

  该构造函数接收两个函数作为参数，分别是`resolve`和`reject`。
   当异步操作执行成功后，会将异步操作结果作为参数传入`resolve`函数并执行，此时 `Promise`对象状态从`pending`变为`fulfilled`；
   失败则会将异步操作的错误作为参数传入`reject`函数并执行，此时 `Promise`对象状态从`pending`变为`rejected`；

```js
let a = new Promise(function(resolve,reject){
    if(1){
        console.log(4)
        resolve(1)
    }
})
setTimeout(function(){
    console.log(5)
},1000)
console.log(2)
a.then(function(calue){
    console.log(calue)
})
console.log(3)

//42315
```

```js
var a = new Promise((resolve,reject)=>{
    reject(1)
})
a.catch((i)=>{
    console.log(i)
    return new Promise((resolve,reject)=>{
        reject(2)
    })
}).then((i)=>{
    console.log(i)
})
// 1
//返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
```

- 返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
- 没有return，相当于return Promise.resolve(undefined);
- return非Promise的数据data，相当于return Promise.resolve(data);

### 5.async/await

定义：使异步函数以同步函数的形式书写(Generator函数语法糖)

原理：将`Generator函数`和自动执行器`spawn`包装在一个函数里

形式：将`Generator函数`的`*`替换成`async`，将`yield`替换成`await`

声明

- 函数：`async function Func() {}`
- 函数表达式：`const func = async function() {}`
- 箭头函数：`const func = async() => {}`
- 对象方法：`const obj = { async func() {} }`
- 类方法：`class Cla { async Func() {} }`

**async函数的返回值总是一个Promise**

无论async函数有无await操作，其总是返回一个Promise。因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数。函数内部抛出的错误，会被then的第二个函数或catch方法捕获到

1. 没有显式return，相当于return Promise.resolve(undefined);
2. return非Promise的数据data，相当于return Promise.resolve(data);
3. return Promise, 会得到Promise对象本身

 **await操作符的值**

```
[rv] = await expression（expression可以是任何值，通常是一个promise）
```

expression是Promise，rv等于Promise兑现的值，若Promise被拒绝，则抛出异常，由catch捕获
expression是非Promise，会立即被转换为resolve的Promise，rv等于expression

```js
let a =async function(){
    let b = await l();
    console.log(b)
    let c = await h();
    console.log(c)
    return 2
}
function l(){
    console.log(1)
    return 3
}
function h(){
    console.log(5)
    return 6
}
a().then(function(v){
    console.log(v)
})
    console.log(a)//[λ: a]
//1,[λ: a],3,5,6,2
```

**tips**

返回的Promise对象必须等到内部所有`await命令Promise对象`执行完才会发生状态改变，除非遇到`return语句`或`抛出错误`

任何一个`await命令Promise对象`变为`rejected状态`，整个`Async函数`都会中断执行

希望即使前一个异步操作失败也不要中断后面的异步操作

- 将`await命令Promise对象`放到`try-catch`中
- `await命令Promise对象`跟一个`catch()`

`await命令Promise对象`可能变为`rejected状态`，最好把其放到`try-catch`中

多个`await命令Promise对象`若不存在继发关系，最好让它们同时触发

```js
//变量分别接收Promise
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise();
let bar = await barPromise();
//使用Promise.all
let [foo,bar] = await Promise.all([getFoo(),getBar()]);


```

`await命令`只能用在`Async函数`之中，否则会报错

数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和`Promise.all()`代替

可保留运行堆栈，函数上下文随着`Async函数`的执行而存在，执行完成就消失

# 底层API

## MutationObserver

https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver

当父元素中的元素有删减，会调用该函数。

eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled

tip: 添加合理的判断条件，否则会执行死循环