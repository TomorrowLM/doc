# html

## SEO

- 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可
- 语义化的`HTML`代码，符合W3C规范：语义化代码让搜索引擎容易理解网页
- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取
- 重要内容不要用`js`输出：爬虫不会执行js获取内容
- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容
- 非装饰性图片必须加`alt`
- 提高网站速度：网站速度是搜索引擎排序的一个重要指标

## 标签

文本加粗标签   <strong></strong> <b></b>> 工作里尽量使用strong

文本倾斜标签	<em></em>> 	<i></i>>	工作里尽量使用em

删除线标签	<del></del>>	<s></s>>	工作里尽量使用del

下划线标签	<ins></ins>>	<u></u>	  工作里尽量使用ins

 <sup>上标</sup>  <sub>下标</sub>

超链接a:属性target,'_self'在自身页面打开，'_blank'打开一个新页面

 <base target="_blank">  让所有的超链接都在新窗口打开

锚链接：<p id="sd"></p>	<a href="#sd">回到顶部</a>

关键字：<mate name="keyword" content="">

网页描述:<mate name="description" content="">

网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com">

设置icon图标：<link rel="icon" href="xxx.ico">

img:`title`当鼠标滑动到元素上的时候显示,`alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片


## 表格

table thead th tr td

​		  tbotd th tr td

cellspacing：表示各单元格之间的空隙

cellpadding：表示单元格内容与单元格边界之间的距离

border-collapse:collapse;边框合并  

表头 <caption></caption>  

colspan=”2” 合并同一行上的单元格

rowspan=”2” 合并同一列上的单元格

```
table    { display: table }
tr       { display: table-row }
thead    { display: table-header-group }
tbody    { display: table-row-group }
tfoot    { display: table-footer-group }
col      { display: table-column }
colgroup { display: table-column-group }
td, th   { display: table-cell }
caption  { display: table-caption }
HTML Table是指使用原生的<table>标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。
display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。
```

## 表单

<fieldset></fieldset>  对表单信息分组

<legend>分组</legend>   表单信息分组名称

<optgroup label=""></optgroup>  对下拉列表select进行分组。Label=”” 分组名称。

```html
  <fieldset>
          <legend>信息分组名称</legend>
          <select name="" id="">
            <optgroup label="1">
              <option value="1">1</option>
              <option value="1">1</option>
            </optgroup>
          </select>
</fieldset>
```

### 表单元素属性

- value 用于大部分表单元素的内容获取(option除外)
- type 可以获取input标签的类型(输入框或复选框等)
- disabled 禁用属性
- checked 复选框选中属性
- selected 下拉菜单选中属性

## tips

**标签语义化**：尽可能少的使用无语义的标签div和span；

**Charset  编码**：

Ascll	Ansi	Unicode  Gbk 	Gb2312	Big5	Utf-8  通用字符集

# html5

## 标签

```
<!-- 数据列表 -->
<input type="text" list="input_list">
  <datalist id="input_list">
    <option value="laoma"></option>
    <option value="lisi"></option>
  </datalist>
  
<!--点击展示详细信息-->
<details>
    <summary>HTML 5</summary>
    <h1>This slide deck teaches you everything you need to know about HTML 5.</h1>
</details>

<!--小窗口-->
<iframe src="https://www.baidu.com" frameborder="0"></iframe>
```

```
<form action="#" method="">
    <input type="text">
    <input type="image" src="toy.png">
    <input type="submit">
    <!-- file text password radio checkbox button image submit reset select button -->
    <input type="date">
    <input type="color">
    <input type="range" min="0" max="10" step="1" value="2">
    <hr>
    <input type="text" required>
    <input type="email" value="some@email.com">
    <input type="date" min="2010-08-14" max="2011-08-14" value="2010-08-14">
    <input type="range" min="0" max="50" value="10">
    <input type="search" results="10" placeholder="Search...">
    <input type="tel" placeholder="(555) 555-5555" pattern="^\(?\d{3}\)?[-\s]\d{3}[-\s]\d{4}.*?$">
    <input type="color" placeholder="e.g. #bbbbbb">
    <input type="number" step="1" min="-5" max="10" value="0">
  </form>
```



# css

## class命名规范

https://www.cnblogs.com/yyzyou/p/7920023.html

### 整体结构

头：header

内容：content/container

页面主体：main

侧栏：sidebar

栏目：column

页面外围控制整体布局宽度：wrapper

方向：left right center top bottom

内部： in

尾：footer

版权：copyright

### 菜单和导航

导航：nav

　　主导航：mainbav

　　子导航：subnav

　　顶导航：topnav

　　边导航：sidebar

　　左导航：leftsidebar

　　右导航：rightsidebar

菜单：menu

　　子菜单：submenu

​	   下拉菜单:dropmenv

标签页：tab

### title

| 文章列表：list  | 提示信息：msg | 小技巧：tips |
| --------------- | :-----------: | ------------ |
| 栏目标题：title |  字体：font   | 注释：note   |
| 文本：text      | 摘要: summary |              |
|                 |               |              |

### 动词

| 加入：joinus   | 指南：guild | 服务：service |
| -------------- | ----------- | ------------- |
| 注册：regsiter | 投票：vote  | 滚动：scroll  |
| 下载：download |             |               |
|                |             |               |

### 形容词

| 当前的: current |      |      |
| --------------- | ---- | ---- |
|                 |      |      |
|                 |      |      |
|                 |      |      |

### 功能

|   登录条：loginbar   |  广告：banner   |   功能区：shop    |
| :------------------: | :-------------: | :---------------: |
|      按钮：btn       |   图标: icon    |     线：line      |
|      热点：hot       |   新闻：news    | 合作伙伴：partner |
| 友情链接：friendlink | 版权：copyright |    标签:label     |
|      图片：pic       | 首页：homepage  |                   |

样式文件命名
　　主要的:master.css
　　布局版面:layout.css
　　专栏:columns.css
　　文字:font.css
　　打印样式:print.css
　　主题:themes.css

## 行内元素和块元素

https://blog.csdn.net/Jwhahaha/article/details/102483938

### 块级元素

可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：

- 每个块级元素都是独自占一行。 
- 元素的高度、宽度、行高和边距都是可以设置的。　　 
- 元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,**高度由内容撑开**

```
h1~h6:标题标签，用于标记网页中的大标题，依次从大到小
p：用于标记网页中的段落性文字，默认占满横向区域
div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽
section：区段，是用来定义文档的某个区域，章节
nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。
header：标签定义文档的页眉
footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等
pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。
address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行
audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。
/ 表格标签 /
table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸
thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加
tbody：表主体，一般省略不写，浏览器在解析时会自动添加
tr：表示一行
th：表头中的第一个单元格
td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列
/ 有序列表，无序列表 /
ul：无序列表
ol：有序列表
li：列表项
dl：定义列表，用于描述类表中的项目（dt（dd））
```

### **行内元素 inline**

行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： 

- 每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 
- 行内元素的高度、宽度、行高不可设置。 
- 元素的宽度就是它包含的文字或图片的宽度，不可改变。

- **行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以**

常见行内元素有以下：

```
span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化

a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件
有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址
strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容

b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调
s：删除线，仅仅是删除的效果
del：具有删除语义，delete删除
em：强调文本，斜体展示
sup：上标
sub：下标
```

### **行内块级元素 inline-block**

行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：

- 和其他行内或行内块级元素元素放置在同一行上；
- 元素的高度、宽度、行高以及顶和底边距都可设置。

```
img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示
button：按钮
input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。

单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值
type="checkbox"复选框

label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态
select:下拉列表
option:下拉选项
```

## float和position

### float

- 设置元素浮动后，对应的元素会脱离文档流，该元素的 `display` 值自动变成 `block`

- float 出现的根本意义只是用来让文字环绕图片而已。

- float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。

- 假如某个div元素A是浮动的，如果A元素**上一个元素也是浮动的**，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素**上一个元素是标准流中的元素**，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。https://blog.csdn.net/qq_36595013/article/details/81810219

  <img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。

  <img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

  把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。

- **清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。**

  ```
  clear :none| left |right  | both
  none :允许两边都可以有浮动对象
  both :不允许有浮动对象
  left :不允许左边有浮动对象
  ```

- 作用

  ```css
  1.CSS浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。
  （1）父元素使用overflow:hidden来清除浮动，最好加上zoom:1;
  （2）父级div定义height
  （3）在父元素后面使用伪类：after和zoom
  .box:after{
  display:block;
  content:"";
  height:0;
  clear:both;
  }
  （2）结尾处加空div标签clear:both
  （2）对父元素设置display:table；使父元素形成BFC（块格式化上下文）
  			BFC三个特性:防止上下margin重叠，防止浮动元素重叠，防止浮动塌陷
  
  2.父级元素内部有子元素，如果给子元素添加margin-top样式，那么父级元素也会跟着下来，造成外边距塌陷。
  给父级元素添加overflow:hidden
  ```

### position

- **position:absolute**
  - 会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。
  - **Z-index 仅能在定位元素上奏效（例如 position:absolute;）！** 
  - 脱离文档流

- **position:relative**

  - 相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化

    ```css
    background-color: green;
        position: relative;
        top: 50px;
        left: 100px;
    ```

    ![img](https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip|imageView2/2/w/535/format/webp)



- **Position:fixed**
  - 固定定位之后，不占据原来的位置（脱标）
  - 元素使用固定定位之后，会转化为行内块


不同点：position相应的块级元素会覆盖下面的内容（文字），而float只会覆盖块级元素，里面的文字会脱离

## BFC

BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响

**触发条件 (以下任意一条)**

- `float`的值不为`none`
- `overflow`的值不为`visible`
- `display`的值为`table-cell`、`tabble-caption`和`inline-block`之一
- `position`的值为`absolute`或者`fixed`

> 在`IE`下, `Layout`,可通过`zoom:1` 触发

**.BFC布局与普通文档流布局区别 普通文档流布局:**

- 浮动的元素是不会被父级计算高度
- 非浮动元素会覆盖浮动元素的位置
- `margin`会传递给父级元素
- 两个相邻元素上下的`margin`会重叠

**BFC布局规则:**

- 浮动的元素会被父级计算高度(父级元素触发了`BFC`)
- 非浮动元素不会覆盖浮动元素的位置(非浮动元素触发了`BFC`)
- `margin`不会传递给父级(父级触发`BFC`)
- 属于同一个`BFC`的两个相邻元素上下`margin`会重叠

**开发中的应用**

- 阻止`margin`重叠
- 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 `div`都位于同一个 `BFC` 区域之中)
- 自适应两栏布局
- 可以阻止元素被浮动元素覆盖

## 字体

- **font-variant :** **normal** | **small-caps**  设置字母字体 

  **normal :** 正常的字体 	**small-caps :** 小型的大写字母字体 这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。

- **text-transform :** **none** | **capitalize**  | **uppercase** | **lowercase** 

  **capitalize :** 　将每个单词的第一个字母转换成大写，其余无转换发生
  **uppercase :**  转换成大写
  **lowercase :** 　转换成小写

- **text-decoration:** none  |   underline   |     line-through



- **line-height :** **normal** | *length*  | inherit  	行高 **行高是指文本行基线间的垂直距离** 

  https://blog.csdn.net/a2013126370/article/details/82786681

  *length :* 　百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小

![img](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	line-height=font-size+行间距

​	height=line-height相等元素垂直居中

- 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的
- 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容
- 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中



- **vertical-align :** **baseline** |**sub**  | **super** |**top** |**text-top** |**middle** |**bottom**  |**text-bottom** |*length* 

-  该属性定义**行内块元素 表格单元格元素 **的基线相对父元素的基线的垂直对齐。允许指定负长度值和百分比值。 

  生效条件：

  - 子元素中的（inline-block/inline元素，eg:image）vertical-align才能起作用。
  - vertical-align不可继承，必须对子元素单独设置。



- **text-indent :** *length* 检索或设置对象中的文本的缩进。

- **letter-spacing :** **normal** | *length* （length允许为负值,px）检索或设置对象中的文字之间的间隔。

- **text-size-adjust**：auto | none | percentage 检索或设置移动端页面中对象文本的大小调整。

  auto：文本大小根据设备尺寸进行调整。

  none：文本大小不会根据设备尺寸进行调整。

  percentage用百分比来指定文本大小在设备尺寸不同的情况下如何调整。

- **direction**: rtl把文本方向设置为“从右向左”；
  ltr 	默认。文本方向从左到右。
  rtl 	文本方向从右到左。
  inherit 	规定应该从父元素继承 direction 属性的值。
  - **word-wrap**   **white-space**

  ```css
  word-wrap:
  normal	只在允许的断字点换行（浏览器保持默认处理）。
  break-word 允许长单词换行到下一行 
  break-word表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。
  //这个属性最初是由微软发明的,但W3C决定要用overflow-wrap替换word-wrap
  overflow-wrap 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。
  
  white-space:设置如何处理元素中的 空白。
  normal    连续的空白符会被合并，换行符会被当作空白符来处理。
  nowrap    和normal一样，连续的空白符会被合并。但文本内的换行无效。直到遇到 <br> 标签为止。
  pre       连续的空白符会被保留。在遇到换行符或者<br>元素时才会换行。
  pre-wrap  连续的空白符会被保留。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时才会换行(溢出了盒子)。
  pre-line  连续的空白符会被合并。在遇到换行符或者<br>元素，或者需要为了填充「行框盒子(line boxes)」时会换行。
  ```

  

- **text-overflow :** **clip** | **ellipsis** 

  **clip :** 　不显示省略标记（...），而是简单的裁切 
  **ellipsis :** 　当对象内文本溢出时显示省略标记（...）  

- 文本缩略

  ```css
  section:nth-of-type(4)  p{
  			width: 200px;
  			border: 1px solid #ccc;
  			/*强制不换行 只在一行缩略  white-space: nowrap;*/
  			overflow: hidden;防止文本溢出
  			text-overflow: ellipsis;产生.....的效果
  			display:-webkit-box;
  			/*-webkit-line-clamp:n;第n行缩略*/
  			-webkit-line-clamp:2;
  			-webkit-box-orient:vertical;
  }
  ```

  



## 连写

font: font-style font-weight font-size/line-height font-family;

文本属性连写文字大小和字体为必写项。



border:color  style(solid实线dotted 点线dashed 虚线)   width

没有顺序要求，线型为必写项。

Padding: 20px;  上右下左内边距都是20px

Padding: 20px 30px;  上下20px  左右30px

Padding: 20px 30px 40px;  上内边距为20px 左右内边距为30px  下内边距为40

Padding: 20px 30px  40px 50px;  上20px 右30px 下40px 左 50px

## 裁剪图像

**clip :** **auto** | **rect (** *number  number number number* **)**依据上-右-下-左的顺序剪切图像。必须将[position](c_position.html)的值设为absolute，此属性方可使用。

clip-path  裁切一个圆角 inset(<top> <right> <bottom> <left> round <top-radius> <right-radius><bottom-radius> <left-radius>) 

## 布局

### 元素的水平居中

- 元素为行内元素，设置父元素`text-align:center`

- 如果子元素宽度固定，可以设置左右`margin`为`auto`;

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              top: 0;
              left: 50%;
              transform: translate( -50%,0);
          }
  ```

- 使用`flex-box`布局，指定`justify-content`属性为center

- `display`设置为`tabel-cell`

### 元素的垂直居中

- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`

- 使用`flex`布局，设置为`align-item：center`

- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`

- 绝对定位和移动: `absolute + transform`

  ```
  .parent_box{
              width: 400px;
              height: 200px;
              position: relative;
          }
          .child_box{
              width: 200px;
              height: 100px;
              position: absolute;
              left: 0;
              top: 50%;
              transform: translate( 0，-50%);
          }
  ```

- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值

- 文本垂直居中设置`line-height`为`height`值

- **如何垂直居中一个`<img>`**

  ```css
  #container     /**<img>的容器设置如下**/
  {
      display:table-cell;
      text-align:center;
      vertical-align:middle;
  }
  ```

### 实现已知或者未知宽度的垂直水平居中

```css
/** 1 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 100px;
    height: 100px;
    margin: -50px 0 0 -50px;
  }
}

/** 2 **/
.wraper {
  position: relative;
  .box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
}

/** 3 **/
.wraper {
  .box {
    display: flex;
    justify-content:center;
    align-items: center;
    height: 100px;
  }
}

/** 4 **/
.wraper {
  display: table;
  .box {
    display: table-cell;
    vertical-align: middle;
  }
}
```

## 选择器

### 优先级

1. 在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。

2. 作为style属性写在元素内的样式 优先级1000

3. id选择器                                        优先级100

4. 类选择器和伪类和属性 				优先级10

5. 标签选择器和伪元素                     优先级1

6. 通配符选择器                                优先级0

7. 浏览器自定义或继承                    没有优先级

   **总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性**

 1.如果是两种相同优先级 为同一个元素 同一个属性设置 的话，是哪个写在代码靠后 最终就按那个的样式

 2.交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较

 3.并集的话 就是各算各的。

### 属性选择器

```css
/* 存在title属性的<a> 元素 */
a[title]
/* 存在href属性并且属性值匹配"https://example.org"的<a> 元素 */
a[href="https://example.org"]
/* 存在href属性并且属性值包含"example"的<a> 元素 */
a[href*="example"]
/* 存在href属性并且属性值结尾是".org"的<a> 元素 */
a[href$=".org"] 
/* 存在class属性并且属性值包含以空格分隔的"logo"的<a>元素 */
a[class~="logo"]
```

### 组合选择器

相邻兄弟选择器 A + B
普通兄弟选择器 A ~ B
子选择器 A > B
后代选择器 A B

交集 
A.B{
} 
并集 
A, B｛
｝ 

### 伪类选择器

```
a:link{属性:值;}       链接默认状态	 
a:visited{属性:值;}     链接访问之后的状态 
a:hover{属性:值;}      鼠标放到链接上显示的状态  	a:active{属性:值;}      链接激活的状态
a:focus{属性:值；}     获取焦点
```

- `p:first-of-type` 选择属于其父元素的首个`<p>`元素的每个`<p>` 元素。
- `p:last-of-type` 选择属于其父元素的最后 `<p>` 元素的每个`<p>` 元素。
- `p:only-of-type` 选择属于其父元素唯一的 `<p>`元素的每个 `<p>` 元素。
- `p:only-child` 选择属于其父元素的唯一子元素的每个 `<p>` 元素。
- `p:nth-child(2)` 选择属于其父元素的第二个子元素的每个 `<p>` 元素。
- `p:nth-of-type(n)` 选择E的父元素下的第n个E元素
- `:after` 在元素之前添加内容,也可以用来做清除浮动。
- `:before` 在元素之后添加内容。
- `:enabled` 已启用的表单元素。
- `:disabled` 已禁用的表单元素。
- `:checked` 单选框或复选框被选中。
- `:empty` 选中没有任何子节点的E元素；

### 伪元素选择器

```
伪元素特性
减少 dom 节点数,但不利于不利于 SEO
它不存在于文档中，所以 js 无法操作它
它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件
```

- E::selection 可改变选中文本的样式


- E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholder，具体参考手册进行对比。


- E:after、E:before 在旧版本里是伪类，在新版本里是伪元素，新版本下E:after、E:before会被自动识别为E::after、E::before，按伪元素来对待。

  ```css
  块级元素才能有:before, :after，譬如 img 就不能设置，亦即某些元素是没有:before, :after 的
  伪类元素的display是默认值inline
  
  （1）各种图标
  利用这两个伪类，可以实现需要简单的图标
  （2）attr()
  通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。
  a::after{
      content:  attr(href) ;
  }
  element.setAttribute("data-age",age);
  element.dataset["age"]
  <a href="http://www.cnblogs.com/starof">starof</a>
  （3）引用媒体文件
  a::before{
      content: url("https://www.baidu.com/img/baidu_jgylogo3.gif");
  }
  （4）清除浮动
  .cf:before,
  .cf:after {
      content: " ";
      display: table; 
  }
  .cf:after {
      clear: both;
  }		
  ```


## 美化

 **搜索框右侧小图标如何美化？**

```css
input[type="search"]::-webkit-search-cancel-button{
  -webkit-appearance: none;
  height: 15px;
  width: 15px;
  border-radius: 8px;
  background:url("images/searchicon.png") no-repeat 0 0;
  background-size: 15px 15px;
}
```

## tips

- Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数


- ```
  visibility:hidden; 隐藏元素  隐藏之后还占据原来的位置。
  opacity=0，该元素隐藏起来了，但不会改变页面布局,还占据原来的位置
  display:none;隐藏元素  隐藏之后不占据原来的位置。
  ```

  

  ```
  透明度
  background-color: rgba(0, 0, 0, 0.3);
  opacity: 0.3;
  transparent是颜色的一种，这种颜色叫透明色。
  ```

- placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）

  ```
  
  input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-moz-placeholder, textarea:-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input::-moz-placeholder, textarea::-moz-placeholder {
      color: #666;
      font-size: 16px;
    }
    
    input:-ms-input-placeholder, textarea:-ms-input-placeholder {
      color: #666;
      font-size: 16px;
    }
  ```


# css3

### 盒模型

https://www.imooc.com/article/68238

<img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg" style="zoom:50%;" />

标准盒子模型

```
盒子实际内容（content）的width/height=我们设置的width/height;
盒子总宽度/高度=width/height+padding+border+margin。
```

IE盒子模型

```
content宽度+内边距padding+边框border宽度=我们设置的width(height也是如此)
盒子总宽度/高度=width/height + margin = content宽度/高度 + padding + border + margin
```

**box-sizing 常用的属性有哪些？分别有什么作用**

- `box-sizing: content-box;` 默认的标准(W3C)盒模型元素效果
- `box-sizing: border-box;` 触发怪异(IE)盒模型元素的效果
- `box-sizing: inherit;` 继承父元素 `box-sizing` 属性的值

### 阴影：

文本阴影：text-shadow 

color  length  lenth opacity  [ inset(阴影向内) ] 

颜色 水平偏移量  垂直偏移量  模糊度  （缩展量）

边框阴影 ：border-shadow

box-shadow：[inset(阴影向内)]  水平偏移量  垂直偏移量  模糊度  （缩展量）  颜色

### 边框圆角box-radius :

 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（**顺时针方向**） 

 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。 

 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角 

 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;

**outline :**[ **outline-color** ](c_outlinecolor.html)||[**outline-style** ](c_outlinestyle.html)||[ **outline-width** ](c_outlinewidth.html)

设置或检索对象外的线条轮廓。outline画在[border](c_border.html)外面，并且不一定是矩形

### 边框图像：

```
border-image-source: url(images/border.png);
border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。
border-image-width: 10px;指定图像边界的宽度：
border-image-repeat: round/stretch/repeat;
```

### 盒模型：

box-sizing:border-box;使width包含内容，padding，和border

元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。 		

content-box,width只包含内容

### 背景

**background:color url  repeat position  attachment**

设置背景颜色会填充content,padding。

连写的时候没有顺序要求，url为必写项  

- **background-position:left top**

- **background-attachment :** **scroll** | **fixed**  

  **scroll :** 　背景图像是随对象内容滚动
  **fixed :** 　背景图像固定 

- **background-clip**：padding-box/content-box/border-box;  修改背景颜色区域/规定背景的绘制区域。

- **background-origin:** border-box;修改背景图片所在区域

- **background-position:**center center;图片水平垂直居中

```
background-size
cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。
contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。

```

### 渐变

```
background-image：linear-gradient();radial-gradient()
repeating-linear-gradient   repeating-radial-gradient
```

### 伸缩布局

```
display: flex; 会浮动
justify-content: space-between;两端对齐布局（伸缩布局）
```

```
flex-direction: column;决定主轴的方向(即子元素的排列方向)
调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse
```

```
justify-content（水平方向）定义了子元素在主轴上的对齐方式
主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式  
```

```
align-items（垂直方向）定义子元素在侧轴上如何对齐
调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch
```

```
 flex-wrap 
 控制是否换行，包括wrap、nowrap （不换行）
```

```
align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用
可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch 
```

```
flex 
控制子元素伸缩比例 
```

```
align-self 侧轴上单个项目对齐方式
单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch 
```

```
flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。

flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
```

order **定义子元素的排列顺序, 数值越小 排列越靠前 默认为0** 

### 多列布局

```
/*设置分成几列*/-webkit-column-count: 4;
/*当列宽*列数乘积大于盒子总宽，会自动调整列数*/
-webkit-column-width: 400px;
/*调整列之间的宽度*/
-webkit-column-gap: 60px;
-webkit-column-rule: 2px dashed #CCC;

//标题单独置一列
/*all代表所有列*/
-webkit-column-span: all;
```



```
设置分成几列-webkit-column-count: 3;
当列宽*列数乘积大于盒子总宽，会自动调整列数-webkit-column-width: 200px;
调整列之间的宽度-webkit-column-gap: 60px;
-webkit-column-rule: 2px dotted #CCC;分割线设置
```

### 响应式

- https://blog.csdn.net/liwusen/article/details/80834546

  - 像素

    像素是网页布局的基础，**一个像素表示了计算机屏幕所能显示的最小区域**，像素分为两种类型：**css像素和物理像素**。

    我们在js或者css代码中使用的px单位就是指的是css像素，物理像素也称设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，**设备的密度越高，物理像素也就越多**。

    ```
    //有一个750px * 1134px的视觉稿
    //pc端的布局视口通常情况下为980px
    PC端： 1 CSS像素 = 物理像素／分辨率 = 750 ／ 980 =0.76 px
    //移动端以iphone6为例，分辨率为375 * 667
    iphone6：1 CSS像素 = 物理像素 ／分辨率 = 750 ／ 375 = 2 px
    //在PC端，一个CSS像素可以用0.76个物理像素来表示，而iphone6中 一个CSS像素表示了2个物理像素。
    ```

- rem相对于根元素html的font-size值的大小

- 百分比的具体分析


1. 子元素**width**或**height**的百分比是**父元素width或height的百分比**
2. **top**、**bottom**的百分比是相对于(默认定位)**父元素的height**
3. **left**、**right**的百分比是相对于(默认定位)**父元素的width**
4. **padding**、**margin**不论是垂直方向或者是水平方向，都相对于直接**父元素的width**
5. **border-radius**、**translate**、**background-size**的百分比，则是相对于**自身的width**

#### PC

- 查看设计图，需要尽可能的添加多的div来包含元素

- 外层盒子使用flex进行布局，不设置绝对宽度px(使用rem或者%布局)，高度由里面的内容撑开（撑不开就用margin、padding）。内层盒子使用%布局。
- float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。


- 图片的自适应（fluid image）

  ```
  img { width: auto; max-width: 100%; }
  ```


#### 移动端

- yd ui 移动端自适应的方案https://blog.csdn.net/weixin_44823323/article/details/99640765

```css
rem (font size of the root element) 是相对根元素 的字体大小变化而变化的css单位，实现强大的屏幕适配布局是它的优势；
不同屏幕大小的终端，它的根元素 的字体大小是需要相应变化的，一般由 JS 控制或者 media query 控制；
既然 rem 是一个css单位，编写样式的时肯定得将设计图中的px转为rem
需要解决的问题
1、如何根据不同大小的屏幕修改根元素 的字体大小？
2、写样式时，如何将设计MM给的图轻松转换为css对应的rem？
/**
   * YDUI 可伸缩布局方案
   * rem计算方式：设计图尺寸px / 100 = 实际rem  【例: 100px = 1rem，32px = .32rem】
*/
!(function (window) {
         /* 设计图文档宽度 */
         var docWidth = 375;
         var doc = window.document,
     docEl = doc.documentElement,
     resizeEvt =
       "orientationchange" in window ? "orientationchange" : "resize";
         var recalc = (function refreshRem() {
     var clientWidth = docEl.getBoundingClientRect().width;
     /* 8.55：小于320px不再缩小，11.2：大于420px不再放大 */
     docEl.style.fontSize =
       Math.max(Math.min(20 * (clientWidth / docWidth), 11.2), 8.55) * 5 +
       "px";
     return refreshRem;
         })();
         /* 添加倍屏标识，安卓为1 */
         docEl.setAttribute(
     "data-dpr",
     window.navigator.appVersion.match(/iphone/gi)
       ? window.devicePixelRatio
       : 1
         );
         if (/iP(hone|od|ad)/.test(window.navigator.userAgent)) {
     /* 添加IOS标识 */
     doc.documentElement.classList.add("ios");
     /* IOS8以上给html添加hairline样式，以便特殊处理 */
     if (
       parseInt(
         window.navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)[1],
         10
       ) >= 8
     )
       doc.documentElement.classList.add("hairline");
         }
         if (!doc.addEventListener) return;
         window.addEventListener(resizeEvt, recalc, false);
         doc.addEventListener("DOMContentLoaded", recalc, false);
       })(window);


```

- https://www.jianshu.com/p/b00cd3506782

```js
(function (doc, win) {
        var docEl = doc.documentElement,
            resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
            recalc = function () {
                var clientWidth = docEl.clientWidth;
                if (!clientWidth) return;
                if(clientWidth>=640){
                    docEl.style.fontSize = '100px';
                }else{
                    docEl.style.fontSize = 100 * (clientWidth / 640) + 'px';
                }
            };

        if (!doc.addEventListener) return;
        win.addEventListener(resizeEvt, recalc, false);
        doc.addEventListener('DOMContentLoaded', recalc, false);
    })(document, window);
```



### 动画

animate.css动画框架

过渡：

transition:

property – 什么属性将用动画表现，例如, opacity。

duration –  过渡的时间 

transition-delay – 设置过渡延时

timing-function  – 过渡的速度;

匀速linear  逐渐降速ease 加速ease-in 降速ease-out  先加速后减速ease-in-out

```
transform 和 transition 属性实现简单旋转效果的例子：

<div style="transition: transform 3s ease-in" 
  onclick="this.style.transform='rotate(360deg)'">
点击这个方块，能让它旋转起来。
</div>
```



动画相比过渡可以控制更多细节，可以将一个动画拆成多个步骤

animation: change 5s infinite;

@keyframes change {0%{}	25%{}	100%{}}

​			动画名称

/*	animation-duration: 1s;
			动画结束后的状态
/*			animation-fill-mode: forwards;
			无限次播放
/*			animation-iteration-count: infinite;
			动画延时
/*			animation-delay: 1s;
			动画暂停
/*			animation-play-state: paused;
			动画反方向
/*			animation-direction: alternate;
			动画速度
/*			animation-timing-function: linear;

### 转化

transform-origin: left bottom;旋转的定位点

transform: rotate(360deg);旋转   

rotate：2D平面旋转顺时针旋转指定的角度。	

3D: transform-style: preserve-3d;	 transform: rotateY/X(0deg);

transform:scale(1.5);盒子扩大1.5倍

```
如何实现小于12px的字体效果
transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;

transform: scale(0.7);
```

缩放 scale(x, y) 可以对元素进行水平和垂直方向的缩放  

transform: skew(45deg);倾斜              

transform: translate(400px) 向左移动400px	translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%

### 视距

perspective: 500px;	近大远小	元素定义perspective属性，其子元素会获得透视效果（透视效果是写在父亲身上），而不是元素本身。只有3D才有

perspective-origin 灭点/消失点

### 媒体查询

```
@media screen and (max-width:600px) {   
body {      background-color: blue;   }}
@media screen and (min-width:900px) {  
body {      background-color: red;   }}

```

# js

## 通识

```
变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头
驼峰命名法。首字母小写，后面单词的首字母需要大写
```

**数值判断**

- NaN：not a number 该属性用于指示某个值不是数字。 

  - NaN 与任何值都不相等，包括他本身

- isNaN: is not a number判断是否是数字，若是数字返回false

- isFinite(number ) 函数用于检查其参数是否是无穷大。

  **提示：** 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。

```
undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined
null表示一个空，变量的值如果想为null，必须手动设置
```

```
布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象
							     转换成false  空字符串  0  false  null  undefined
```

转换成字符串类型：

- toString() String() 拼接字符串方式

**转换成数值类型：**

- 1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN 

- 2.parseInt() 

- 3.parseFloat()

**堆栈**

**栈：**

- 存储基础数据类型

- 栈会开辟一个内存

- 按值访问

- 存储的值大小固定

- 由系统自动分配内存空间

- 空间小，运行效率高

- 先进后出，后进先出

- 栈中的DOM，ajax，setTimeout会依次进入到队列中,当栈中代码执行完毕后，再将队列中的事件放到执行栈中依次执行。

- 微任务和宏任务

  **栈先进后出，队列先进先出**

**堆:**

- 存储引用数据类型
- 堆共用同一个内存
- 按引用访问
- 存储的值大小不定，可动态调整
- 主要用来存放对象
- 空间大，但是运行效率相对较低
- 无序存储，可根据引用直接获取


## 位置

### 获取鼠标当前位置（事件对象）

- offsetY、offsetY：  鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。内填充边意思是不包含border，但包含padding，类似于padding-box。

- clientY、clientX： 鼠标当前位置 相对于 **视口**顶部、浏览器可视区域左部 的位置；

- pageY、pageX：     鼠标当前位置 相对于 **页面**/文档顶部、页面/文档左部的位置；

- screenY、screenX：鼠标当前位置 相对于 **屏幕**顶部、屏幕左部的位置；

  **他们均是鼠标事件的一级属性 ，如e.clientY**

![图片描述](https://segmentfault.com/img/bVXWPA?w=1043&h=552)

浏览器的可视区域的坐标e.clientX/Y 设置或获取鼠标指针位置相对于`浏览器视口（内容区域的左上角）`的坐标，与浏览器是否有滚动条无关 

screenX，screenY 鼠标指针位置相对于浏览器中完`全呈现的内容区域`

![img](https://upload-images.jianshu.io/upload_images/1811036-510a2fbcd5bb2d17.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)



Element.getBoundingClientRect()   获取元素相对于视口的位置 

top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。

![img](https://upload-images.jianshu.io/upload_images/10862849-ca1fcf2d02453a08.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/240/format/webp)

`window.scrollTo(options)`方法,`options`是一个对象，有三个属性：
`top` 等同于 y-coord
`left` 等同于 x-coord
`behavior` 类型String,表示滚动行为,支持参数 `smooth`(平滑滚动),`instant`(瞬间滚动),默认值auto（等同于`instant`）

### 获取元素当前位置

clientHeight：内容+padding（上下）

clientWidth：内容+padding（左右）

offsetTop：从边框border（不包含）距离父元素的高度距离

offsetLeft：从边框border（不包含）距离父元素的宽度距离

offsetHeight：内容+padding+border

offset Width：内容+padding+border

scrollleft/top 滚动出去的距离 scrollwidth/height 总的宽/高（显示和隐藏的）

## 获取

### 属性获取

- js获取css属性值

  - jquery方法

  ```
  //jquery方法
  const jq_width = $('.box').css('width');
  const jq_lineHeight = $('.box').css('line-height');
  console.log(jq_width,jq_lineHeight);//200px 150px
  ```

  - 然后我们再用js原生方法去获取

  ```js
  // 原生style.css方法
  const box = document.querySelector('.box');
  const js_width = box.style.width;
  const js_lineHeight = box.style.lineHeight;
  console.log(js_width,js_lineHeight);//   50px
  //在这里我们会发现style.css方法只能获取到写在标签上的属性 style = "line-height:150px" 不能获取写在<style>``</style>中的css属性
  ```

  - 使用`window.getComputedStyle`这个方法获取所有经过浏览器计算过的样式

- elementNode.getAttribute(name)：方法通过名称获取属性的值。

  elementNode.setAttribute(name, value)：方法创建或改变某个新属性。

  elementNode.removeAttribute(name)：方法通过名称删除属性的值。


### 节点元素获取

getElementsBy方法都是伪数组arguments

判断当前的子节点是否是元素节点	if (node.nodeType === 1)

parentNode	父元素		childNodes  所有子节点	children    所有的子元素

lastChild    获取最后一个子节点	lastElementChild     获取最后一个子元素

nextSibling  下一个兄弟节点		nextElementSibling	下一个兄弟元素

previousSibling   上一个兄弟节点	 previousElementSibling    上一个兄弟元素

## 字符串

**不会改变原来的字符串**

```js
// 1 字符方法
charAt(index)    	//获取指定位置处字符 myString.charAt(1)
charCodeAt()  	//获取指定位置处字符的ASCII码
// 2 字符串操作方法
concat()   		//拼接字符串，等效于+，+更常用
slice(startIndex,endIndex)
//从start位置开始，截取到end位置，end取不到
//如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。
//如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。
substring(startIndex,endIndex) 	
//从start位置开始，截取到end位置， end取不到
//若startIndex或者endIndex为负，则会被替换为0。
substr(fromIndex,length)   		
//从start位置开始，截取length个字符
//若起始索引为负，则从右往左开始截取
// 3 位置方法
indexOf('' '',[index] )   	//返回指定内容在元字符串中的位置，只找第一个匹配的,若没有则返回-1是，indexOf('a',2);从位置2开始找到a的位置
lastIndexOf() 	//从后往前找，只找第一个匹配的
// 4 去除空白   
trim()  		//只能去除字符串前后的空白，字符之间的空格不能去掉
// 5 大小写转换方法
to(Locale)UpperCase() 	//转换大写
to(Locale)LowerCase() 	//转换小写
//6 split()字符转换为数组 split()还可以结合正则表达式
var str='a,b,c,d';
var arr=str.split(',');//以逗号为分割成数组
arr.join('');
```

## 数组

### 会改变原来数组的有：

#### pop()

删除数组的最后一个元素并返回删除的元素。

#### push()

向数组的末尾添加一个或更多元素，并返回新的长度。

#### shift()

删除并返回数组的第一个元素。

#### unshift()

向数组的开头添加一个或更多元素，并返回新的长度。reverse()---反转数组的元素顺序。

#### reverse()	

翻转数组

#### sort() 	

*arr.sort([comparefn])*

- comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序

- 如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：
  - 若 comparefn(a, b) < 0，那么a 将排到 b 前面；
  - 若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；
  - 若 comparefn(a, b) > 0，那么a , b 将调换位置；

```js
//即使是数组sort也是根据字符，从小到大排序
//采用冒泡排序
sort(fn(a,b){
// 升序
return a - b;
// 倒序
return b - a;
})
fn（a,b）{return <0||>0},返回小于0升序，大于0降序。

```

```
var a = [2,3,1,0].sort(function(a,b){
    console.log(a,b)
    return a-b
})
:3 2
:1 3 
:1 2 
:0 2
:0 1
```

**sort()方法的比较逻辑为：**
前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序

#### splice()

用于插入、删除或替换数组的元素。

```js
arr.splice(start,deleteCount[, item1[, item2[, …]]])

var array = ["one", "two", "four"];
// splice(position, numberOfItemsToRemove, item)
// 拼接函数(索引位置, 要删除元素的数量, 元素)
array.splice(2, 0, "three"); // 
array; //["one", "two", "three", "four"]

var array = ["apple","boy"];
var splices = array.splice(1,1);
console.log(array); // ["apple"]
console.log(splices); // ["boy"] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素
```

数组指定位置插入元素

```
Array.prototype.insert = function (index, item) {
this.splice(index, 0, item);
};
var nums = ["one", "two", "four"];
nums.insert(2, 'three'); // 注意数组索引, [0,1,2..]
array // ["one", "two", "three", "four"]
```



### 不会改变原来数组的有：

#### concat() 

将传入的数组或者元素与原数组合并，组成一个新的数组并返回。

语法：***arr.concat(value1, value2, …, valueN)***

```
var array = [1, 2, 3];
var array2 = array.concat(4,[5,6],[7,8,9]);
console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(array); // [1, 2, 3], 可见原数组并未被修改
```

若concat方法中不传入参数，那么将基于原数组**浅复制**生成一个一模一样的新数组（指向新的地址空间）。

```js
var array = [{a: 1}];
var array3 = array.concat();
console.log(array3); // [{a: 1}]
console.log(array3 === array); // false
console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用
```

#### join() 

将数组中的所有元素连接成一个字符串。

语法：*arr.join([separator = ‘,’])* separator可选，缺省默认为逗号。

```
var array = ['We', 'are', 'Chinese'];
console.log(array.join()); // "We,are,Chinese"
console.log(array.join('+')); // "We+are+Chinese"
console.log(array.join('')); // "WeareChinese"
```

#### slice() 

将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。

语法：*arr.slice([start[, end]])*

参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。

如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。

slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。

```
var array = ["one", "two", "three","four", "five"];
console.log(array.slice()); // ["one", "two", "three","four", "five"]
console.log(array.slice(2,3)); // ["three"]
123
```

**浅复制** 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。

```
var array = [{color:"yellow"}, 2, 3];
var array2 = array.slice(0,1);
console.log(array2); // [{color:"yellow"}]
array[0]["color"] = "blue";
console.log(array2); // [{color:"bule"}]
12345
```

由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。

#### toString()

#### toLocaleString()

#### indexOf

indexOf(arr[i],[index] )   	//从位置index查找arr[i]在数组中的位置，只找第一个匹配的,若没有则返回-1

#### lastindexOf

## 遍历

### 数组

**迭代方法 不会修改原数组**

every()、filter()、forEach()、map()、some()

#### forEach()

指定数组的每项元素都执行一次传入的函数，返回值为undefined。

语法：**arr.forEach(fn, thisArg)**

fn 表示在数组每一项上执行的函数，接受三个参数：

- value 当前正在被处理的元素的值
- index 当前元素的数组索引
- array 数组本身

thisArg 可选，用来当做fn函数内的this对象。

```js
var array = [1, 3, 5];
var obj = {name:'cc'};
var sReturn = array.forEach(function(value, index, array){
  array[index] = value * value;
  console.log(this.name); // cc被打印了三次
},obj);
console.log(array); // [1, 9, 25], 可见原数组改变了
console.log(sReturn); // undefined, 可见返回值为undefined
```

#### map()

使用传入函数处理每个元素，并返回函数的返回值组成的新数组。

语法：**arr.map(fn, thisArg)**

参数介绍同 forEach 方法的参数介绍。

#### every()

数组的每一项执行的函数都满足条件就返回true

#### some()

对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。

#### filter()

执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素

语法：**arr.filter(fn, thisArg)**

```
var array = [18, 9, 10, 35, 80];
var array2 = array.filter(function(value, index, array){
  return value > 20;
});
console.log(array2); // [35, 80]
```

#### reduce()

reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。

语法：**arr.reduce(fn, initialValue)**

fn 表示在数组每一项上执行的函数，接受四个参数：

- previousValue 上一次调用回调返回的值，或者是提供的初始值
- value 数组中当前被处理元素的值
- index 当前元素在数组中的索引
- array 数组自身

initialValue 指定第一次调用 fn 的第一个参数。

#### entries() 

方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。

语法：**arr.entries()**

```
var array = ["a", "b", "c"];
var iterator = array.entries();
console.log(iterator.next()); //{ value: [ 0, 'a' ], done: false } 
console.log(iterator.next().value); // [0, "a"]
console.log(iterator.next().value); // [1, "b"]
console.log(iterator.next().value); // [2, "c"]
console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined
```

#### keys

keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）

语法：**arr.keys()**

```js
var array = ["abc", "xyz"];
var iterator = array.keys();
console.log(iterator.next()); // Object {value: 0, done: false}
console.log(iterator.next()); // Object {value: 1, done: false}
console.log(iterator.next()); // Object {value: undefined, done: false}
```

#### values()

values() 方法基于**ECMAScript 2015（ES6）规范**，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。

语法：**arr.values()**

遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。

```js
var array = ["abc", "xyz"];
var iterator = array.values();
console.log(iterator.next().value);//abc
console.log(iterator.next().value);//xyz
```

#### for

 **for...in循环**

精准的迭代，可以迭代对象的元素。也可以迭代数组。

【注意】使用`for ... in`，迭代的是元素（keys），对于数组来说，则为下标（0,1,2...,length-1）

```text
for(var key in arr) {
    //执行相关操作
}
```

 **for...of循环（ES6支持）**

```text
for(let item of arr) {
    //执行相关操作
}
```

和`for...in`不同的是，`for...of`迭代出来的是值（value），对于数组来说，则是一个元素值。

### 对象

#### for

**for...in遍历**

```js
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var el in book) {
    console.log(book[el]);
}
```

**for ... of遍历**

此方法，**不能遍历普通对象**(因为能够被for...of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口，使得它无法被for...of遍历。)，需要和`Object.keys()`搭配使用，先获取对象的所有key的数组 然后遍历：

```text
var book = {
    name: "hello",
    id: "2",
    author: "ztyzz",
    time: "2018.2.30"

};
for(var key of Object.keys(book)) {
    console.log(book[key]);
}
```

【注意】`Object.values()`返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。

同时，由于`Object.keys()`返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。

## Math

```js
Math.PI						// 圆周率
Math.random()				// 生成随机数
Math.floor()/Math.ceil()	 // 向下取整/向上取整
Math.round()				// 取整，四舍五入
Math.abs()					// 绝对值
Math.max()/Math.min()		 // 求最大和最小值                                                                                                           
Math.sin()Math.cos()		 // 正弦/余弦
Math.power()/Math.sqrt()	 // 求指数次幂/求平方根
```

## Date

### **new Date()**创建新的日期对象

1. 用整数初始化日期对象

   new Date(yyyy,mth,dd,hh,mm,ss); 
   new Date(yyyy,mth,dd); 

   注意：

   - 您不能省略月份。如果只提供一个参数，则将其视为毫秒。
   - 一位和两位数年份将被解释为 19xx 年：

   ```
   yyyy:四位数表示的年份
   mth:用整数表示月份，从（１月）0到１１（１２月）
   dd:表示一个 月中的第几天，从1到31
   hh:小时数，从0（午夜）到23（晚11点）
   mm: 分钟数，从0到59的整数
   ss:秒数，从0到59的整数
   ```

2. 用字符串初始化日期对象

   new Date("2017/06/06"); 

   new Date(“2017-08-08”); 

   new Date("month dd,yyyy hh:mm:ss");  

   new Date("month dd,yyyy");

3. 用毫秒时间戳初始化日期对象

   new Date(ms);

   ```
   JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。
   零时间是 1970 年 1 月 1 日 00:00:00 UTC。
   ```

   

### 获取日期方法

| 方法              | 描述                                 |
| :---------------- | :----------------------------------- |
| getDate()         | 以数值返回天（1-31）                 |
| getDay()          | 以数值获取周名（0-6）                |
| getFullYear()     | 获取四位的年（yyyy）                 |
| getHours()        | 获取小时（0-23）                     |
| getMilliseconds() | 获取毫秒（0-999）                    |
| getMinutes()      | 获取分（0-59）                       |
| getMonth()        | 获取月（0-11）                       |
| getSeconds()      | 获取秒（0-59）                       |
| getTime()         | 获取时间（从 1970 年 1 月 1 日至今） |

```
date.getFullYear()//获取完整的年份(4位,1970-????)
date.getMonth() //获取当前月份(0-11,0代表1月)
date.getDate()//获取几号   - 0 - 31 比如25
date.getDay()//获取星期几 - 比如星期3的3
date.getHours()//获取小时
date.getTime()// 获取相对于1970-01-01的毫秒值
```

### 日期设置方法

设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：

| 方法              | 描述                                         |
| :---------------- | :------------------------------------------- |
| setDate()         | 以数值（1-31）设置日                         |
| setFullYear()     | 设置年（可选月和日）                         |
| setHours()        | 设置小时（0-23）                             |
| setMilliseconds() | 设置毫秒（0-999）                            |
| setMinutes()      | 设置分（0-59）                               |
| setMonth()        | 设置月（0-11）                               |
| setSeconds()      | 设置秒（0-59）                               |
| setTime()         | 设置时间（从 1970 年 1 月 1 日至今的毫秒数） |

### **时间戳转化为日期的方式**

```
// Mon May 28 2018
console.log(newDate.toDateString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toGMTString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toISOString());
 
// 2018-05-28T15:24:12.000Z
console.log(newDate.toJSON());

// 2018/5/28
console.log(newDate.toLocaleDateString());
 
// 2018/5/28 下午11:24:12
console.log(newDate.toLocaleString());
 
// 下午11:24:12
console.log(newDate.toLocaleTimeString());
 
// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toString());
 
// 23:24:12 GMT+0800 (中国标准时间)
console.log(newDate.toTimeString());
 
// Mon, 28 May 2018 15:24:12 GMT
console.log(newDate.toUTCString());
```



## 正则

replace(被替换，替换)	  stringObj.replace(rgExp, replaceText)

search 返回与正则表达式查找内容匹配的第一个子字符串的位置。stringObj.search(rgExp)

match使用**正则表达式**模式对字符串执行查找，并将包含查找的结果作为数组返回。

exec 用正则表达式模式在字符串中运行查找，并返回包含该查找结果的一个数组。

```
var str='cat,hat';
var p=/at/g;  //g属性
alert(p.exec(str));  //at
alert(str.match(p));  //at   at
exec永远只返回第一个匹配，而match在正则表达式g属性时，会返回所有的匹配。
```

stringObj.match(rgExp)

test 返回一个 Boolean 值，它指出在被查找的字符串中是否存在模式。



## 继承

instanceof判断是否是数组 /判断某个对象是否是某个构造函数的实例    typeof判断类型

任何一个prototype对象都有一个constructor属性，指向它的构造函数，每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性 

#### 构造函数的属性继承：借用构造函数

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

function Student (name, age) {
  // 借用构造函数继承属性成员 
  Person.call(this, name, age)
}

var s1 = Student('张三', 18)
console.log(s1.type, s1.name, s1.age) // => human 张三 18
```

#### 构造函数的原型方法继承：拷贝继承（for-in）

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

Person.prototype.sayName = function () {
  console.log('hello ' + this.name)
}

function Student (name, age) {
  Person.call(this, name, age)
}

// 原型对象拷贝继承原型对象成员
for(var key in Person.prototype) {
  Student.prototype[key] = Person.prototype[key]
}

var s1 = Student('张三', 18)

s1.sayName() // => hello 张三
```

#### 另一种继承方式：原型继承

```javascript
function Person (name, age) {
  this.type = 'human'
  this.name = name
  this.age = age
}

Person.prototype.sayName = function () {
  console.log('hello ' + this.name)
}

function Student (name, age) {
  Person.call(this, name, age)
}

// 利用原型的特性实现继承
Student.prototype = new Person()
// 若不指明原型对象，会指向person
//console.log(Student.prototype.constructor);
Student.prototype.constructor = Student;
var s1 = Student('张三', 18)

console.log(s1.type) // => human

s1.sayName() // => hello 张三
```

## this指向

### call、apply、bind

```
1.1 作用
他们的作用都是改变函数内部的this。
这三个函数都是Function原型中的方法（所有的函数都是Function的实例），也就是说只有函数才可以直接调用这些方法。
1.2 三者区别
参数： 三个函数的第一个参数都是需要绑定的 this。
call/apply 修改完this指向后，会立即调用前面的函数，但是 bind 只是修改this指向，并不会调用
call/bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。
apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。 
    call 语法：  foo.call(this, arg1,arg2, ... ,argn );
    apply 语法： foo.apply(this, [ arg1,arg2, ... ,argn ] );
    bind 语法：  foo.bind(this, arg1,arg2, ... ,argn);
调用：
call,apply： 调用后立即执行原函数。
bind： 调用后返回已经绑定好this的函数。

处理伪数组 (最常用)，继承
```



## 事件流

**e 事件参数（事件对象）**	

事件对象（event）

- `target`是事件触发的真实元素
- `currentTarget`是事件绑定的元素
- 事件处理函数中的`this`指向是中为`currentTarget`。
- `currentTarget`和`target`，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）
  - 当事件是子元素触发时，`currentTarget`为绑定事件的元素，`target`为子元素
    - 若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素           
  - 当事件是元素自身触发时，`currentTarget`和`target`为同一个元素。

e.type点击对象的事件类型

```js
$("a").click(function(event) {
    alert(event.type); // "click"
  }); 
```



```xml
.addEventListener('click', fn, false);//false(默认)是事件冒泡，true是事件捕获
```

```
e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。
```

```
在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。
```

## html5

`HTML5` 现在已经不是 `SGML` 的子集，主要是关于图像，位置，存储，多任务等功能的增加

- 新增选择器 `document.querySelector`、`document.querySelectorAll`
- 拖拽释放(`Drag and drop`) API
- 媒体播放的 `video` 和 `audio`
- 本地存储 `localStorage` 和 `sessionStorage`
- 离线应用 `manifest`
- 桌面通知 `Notifications`
- 语意化标签 `article`、`footer`、`header`、`nav`、`section`
- 增强表单控件 `calendar`、`date`、`time`、`email`、`url`、`search`
- 地理位置 `Geolocation`
- 多任务 `webworker`
- 全双工通信协议 `websocket`
- 历史管理 `history`
- 跨域资源共享(CORS) `Access-Control-Allow-Origin`
- 页面可见性改变事件 `visibilitychange`
- 跨窗口通信 `PostMessage`
- `Form Data` 对象
- 绘画 `canvas`

### Tips

设置属性（setAttribute）,属性名为'data-'开头的，可以使用dataset来获取值

```
setAttribute('data-age', value);      dataset['age']
```

### classList

```
属性length,返回类的数量
classList.item(index)返回元素中索引值对应的类名。索引值从 0 开始。
classList.remove/add/toggle('active')
classList.contains('active')判断当前ClassList中有没有active
classList.toggle('active', '');toggle函数的第二个参数true为添加 false删除
```

### window对象

#### onload

- onload

```javascript
window.onload = function () {
  // 当页面加载完成执行
  // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行
}
```

- onunload

```javascript
window.onunload = function () {
  // 当用户退出页面时执行
}
```

#### location对象

```
window.open('http://www.baidu.com','newwindow','height=500,width=500,top=100,left=100,toolbar=no,menubar=no,scrollbars=no, resizable=no,location=no, status=no')
//    我们可以控制窗口的各种属性：
//    宽为100，高为400，距屏顶0象素，屏左0象素，无工具条，无菜单条，无滚动条，
//    不可调整大小，无地址栏， 
window.location ='test2.html' //改变当前窗口的地址，则会打开新的网页

location.reload(true);    //从服务器重载当前页面//       
location.reload(false);   //从浏览器缓存中重载当前页面//        
location.reload();        //从浏览器缓存中重载当前页面

location.replace("http://www.baidu.com");
//        replace和assign的区别
//        replace()方法所做的操作与assign()方法一样，
//        但它多了一步操作，即从浏览器的历史记录中删除了包含脚本的页面，
//        这样就不能通过浏览器的后退按钮和前进按钮来访问它了，
//        assign()方法却可以通过后退按钮来访问上个页面。
```

#### 历史记录pushState

pushState()可以创建一个**伪造**的历史记录，可以配合popstate事件，而replaceState()则是修改掉当前的URL，不会产生历史。 

**pushState(stateObject,title,URL):**  改变网址却不需要刷新页面 

stateObject（状态对象，一个JavaScript对象，window.history.state可以获取) ，为每个历史记录添加状态

title标题（现在被忽略了）

URL地址（ url可以是绝对的也可以是相对的）。 

无论何时用户后退或前进操作，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝； 

```
if (window.history && history.pushState) {
// 支持历史状态操作
	history.pushState(this.dataset.title, 'title useless', '?t=' + this.dataset.title);
    console.log(e.state);
}
// 在历史状态中前进后退触发该事件
      window.addEventListener('popstate', function(e) {
        console.log(e.state);
        content.innerHTML = data[e.state];
      });   
```

### WEB存储

本地存储使用的是 cookie。但是Web 存储需要更加的安全与快速. 这些数据不会被保存在服务器上，但是这些数据只用于用户请求网站数据上.它也可以存储大量的数据，而不影响网站的性能. 数据以 键/值 对存在,

- localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。

  ```
  // 存储 localStorage.sitename = "菜鸟教程"; 
  // 查找 document.getElementById("result").innerHTML =localStorage.sitename;
  //移除 localStorage 中的 "sitename" :
  localStorage.removeItem("sitename");
  ```

  ```
  不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：
  
  - 保存数据：localStorage.setItem(key,value);
  - 读取数据：localStorage.getItem(key);
  - 删除单个数据：localStorage.removeItem(key);
  - 删除所有数据：localStorage.clear();
  - 得到某个索引的key：localStorage.key(index);
  
  ```

- sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。

# jquery

## 1.

```
当你用的是jquery时，就用$(this)，如果是JS，就用this
jquery对象$(this)[0]等同于JS里的元素this
JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了
$(this).get(0)与$(this)[0]等价。
```

jQuery(selector,[context])如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找

eg:在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。

jQuery 代码:$("input:radio", document.forms[0]);



jQuery(html,[ownerDocument])动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。

```
$("<input>", {
  type: "text",
  val: "Test",
  focusin: function() {
    $(this).addClass("active");
  }).appendTo("form");
```



当DOM加载完成后，执行其中的函数。

```
$(function(){
  // 文档就绪
});//这个函数的作用如同$(document).ready()一样
```



```
$("img").each(function(i){
   this.src = "test" + i + ".jpg";
 });
 
 jQuery 对象中元素的个数。$("img").size();   $("img").length;
```



index(一个DOM选择器/ jQuery 选择器)

```
$('li').index(document.getElementById('bar')); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置
$('#bar').index('li'); //1，传递一个选择器，返回#bar在所有li中的索引位置
$('#bar').index(); //1，不传递参数，返回这个元素在同辈中的索引位置。
```



设置元素属性：jQuery.data([key],[value])  获取元素属性：jQuery.data(key)

## 2.

```
选择器
：not(selector)去除所有与给定选择器匹配的元素
：eq(index)匹配一个给定索引值的元素
:gt(index)匹配所有大于给定索引值的元素--lt
:target 给定的URI http://example.com/#foo,$( "p:target" )，将选择<p id="foo">元素。
:contains(text)匹配包含给定文本的元素
:empty匹配所有不包含子元素或者文本的空元素--parent
:has(selector)匹配含有选择器所匹配的元素的元素

```

## 3.属性

attr(name|key,value)返回或设置被选元素的属性值。removeAttr

```
$("img").attr({ src: "test.jpg", alt: "Test Image" });//为所有图像设置src和alt属性。
$("img").attr("src","test.jpg");//为所有图像设置src属性。
```

addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass

```
$('ul li:last').addClass(function(index,class) {
  return 'item-' + $(this).index();
});//给li加上不同的class
```

toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。

```
  var count = 0;
  $("p").click(function(){
      $(this).toggleClass("highlight", count++ % 3 == 0);
  });//每点击三下加上一次 'highlight' 类
```

val/text/html([val|fn(index,html原先的HTML值)])获取或者设置HTML的内容

## 4.筛选

is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。

map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，

```
$("p").append( $("input").map(function(){
  return $(this).val();
}).get().join(", ") );get()jQuery转DOM对象

$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。
$.map( [0,1,2], function(n){
  return n + 4;
});
```

children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式

find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$("p span")相同。

next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。

nextAll(expr),查找当前元素之后所有的同辈元素。

prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。

siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。

## 5.文档处理

selector.append/appendTo(content|fn)将content添加到匹配的selector中，将匹配的selector添加到content中

prepend/prependTo

after/before   insertAfter/insertBefore

wrap(html|element|fn)把所有匹配的元素用其他元素的结构化标记包裹起来--unwrap

```
$("p").wrap("<div class='wrap'></div>");//把所有的段落用一个新创建的div包裹起来
```

replaceWith/All

empty()删除匹配的元素集合中所有的子节点。

remove("selector")从DOM中删除所有匹配的元素(不包含文本节点)。

## 6.css

$("selector").css(name|pro|[,val|fn(index,value)]);访问或者设置样式属性

```
$("p").css("color");//取得第一个段落的color样式属性的值。
$("p").css({ "color": "#ff0011", "background": "blue" });//将所有段落字体设为红色
$("p").css("color","red");
```

## 7.事件



```
1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。

**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。
**data:**作为event.data属性值传递给事件对象的额外数据对象
**fn:**每当事件触发时执行的函数。

2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 
3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。
事件委托即事件冒泡
// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp
$(document.body).on("click", "p", handler);
e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡
```

trigger(type,[data])在每一个匹配的元素上触发某类事件。

hover([over,]out)

over:鼠标移到元素上要触发的函数

out:鼠标移出元素要触发的函数

toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。

```
$("td").toggle(
  function () {
    $(this).addClass("selected");
  },
  function () {
    $(this).removeClass("selected");
  }
);//对表格的切换一个类
$('td).toggle();//对表格切换显示/隐藏
```

change([data],fn)当元素的值发生改变时，会发生 change 事件。

unload([[data],fn])在当用户离开页面时，会发生 unload 事件。

会发出 unload 事件：

- 点击某个离开页面的链接  
- 在地址栏中键入了新的 URL  
- 使用前进或后退按钮  
- 关闭浏览器  
- 重新加载页面 

## 8.效果

1.show(speed,easing,fn)  hide(),speed动画时常的毫秒数，fn动画完成时执行的函数
2.slideDown(speed,easing,fn) slideUp(),通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数。
3.slideToggle(speed,easing,fn)通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数。
4.fadeIn(speed,easing,fn)通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数。fadeOut
5.fadeTo(speed,opacity,easing,fn)把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数。
6.fadeToggle(speed,easing,fn)通过不透明度的变化来开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数。元素隐藏，则显示。元素显示则开启隐藏效果
7.animate(params,[speed],[easing],[fn])
params:一组包含作为动画属性和终值的样式属性和及其值的集合
$("#go").click(function(){
  $("#block").animate({ 
    width: "90%",
    height: "100%", 
    fontSize: "10em", 
    borderWidth: 10
  }, 1000 );
});
8.stop(clearQueue,jumpToEnd),停止所有在指定元素上正在运行的动画。如果队列中有等待执行的动画(并且clearQueue没有设为true)，他们将被马上执行
clearQueue:如果设置成true，则清空队列。可以立即结束动画。
jumpToEnd:如果设置成true，则完成队列。可以立即完成动画。
9.delay(duration,queueName)设置一个延时来推迟执行队列中之后的项目。
duration:延时时间，单位：毫秒
queueName:队列名词，默认是Fx，动画队列。
10.finish([queue])停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画。

## 9.ajax

## 10.工具

```
1.$.each(object,[callback])通用例遍方法，可用于例遍对象和数组。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。
$().each() 是来遍历DOM对象的
2.$.extend([deep],target,object,[object n])用一个或多个其他对象来扩展一个对象，返回被扩展的对象。target:待修改对象。object1:待合并到第一个对象的对象。合并 settings 和 options，修改并返回 settings。
var settings = { validate: false, limit: 5, name: "foo" };
var options = { validate: true, name: "bar" };
jQuery.extend(settings, options);
settings == { validate: true, limit: 5, name: "bar" }
3.$.grep(array,callback)使用过滤函数过滤数组元素。callback:此函数将处理数组每个元素。第一个参数为当前元素，第二个参数而元素索引值。此函数应返回一个布尔值。过滤数组中小于 0 的元素。
$.grep( [0,1,2], function(n,i){
  return n > 0;
});
4.$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array: 待转换数组。将原数组中每个元素加 4 转换为一个新数组。
$.map( [0,1,2], function(n){
  return n + 4;
});
5.$.inArray(value,array,[fromIndex])确定第一个参数在数组中的位置，从0开始计数(如果没有找到则返回 -1 )。
var arr = [ 4, "Pete", 8, "John" ];
jQuery.inArray("John", arr);  //3
jQuery.inArray(4, arr);  //0
6.$.trim(str),去掉字符串起始和结尾的空格。
7.$.type(obj)检测obj的数据类型。
```

# ES6

## 模块化

### CommonJS

是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。

核心思想
允许模块通过 `require` 方法来同步加载所要依赖的其他模块，然后通过 `exports` 或 `module.exports` 来导出需要暴露的接口。

**优点：**服务器端模块重用，NPM中模块包多，有将近20万个。

**缺点：**加载模块是同步的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

**实现**：

- 服务器端的 [Node.js](http://www.nodejs.org/)
- [Browserify](http://browserify.org/)，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大
- [modules-webmake](https://github.com/medikoo/modules-webmake)，类似Browserify，还不如 Browserify 灵活
- [wreq](https://github.com/substack/wreq)，Browserify 的前身

### **AMD**

鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。

**其核心接口是**：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块**提前执行**，**依赖前置**。

```js
define("module", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
require(["module", "../file"], function(module, file) { /* ... */ });
```

**优点：**在浏览器环境中异步加载模块；并行加载多个模块；

**缺点：**开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；

### **CMD**

Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。

```text
define(function(require, exports, module) {
  var $ = require('jquery');
  var Spinning = require('./spinning');
  exports.doSomething = ...
  module.exports = ...
})
```

**优点：依赖就近，延迟执行**（对于依赖的模块延迟执行，即只在需要用到某个模块的时候再require） 可以很容易在 Node.js 中运行；
**缺点：**依赖 SPM 打包，模块的加载逻辑偏重；
**实现：Sea.js** ；coolie

### **ES6**

ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。[ES6 模块](http://es6.ruanyifeng.com/#docs/module)的设计思想，是尽量的静态化，使得**编译**时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。**但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require**。

```js
import "jquery";
export function doStuff() {}
module "localModule" {}
```

优点：

- 容易进行静态分析
- 面向未来的 ECMAScript 标准

缺点：

- 原生浏览器端还没有实现该标准
- 全新的命令字，新版的 Node.js才支持

### commonjs和ES6的区别

- **CommonJS**的`require`语法是同步的，所以就导致了**CommonJS**模块规范只适合用在服务端，而ES6模块无论是在浏览器端还是服务端都是可以使用的，但是在服务端中，还需要遵循一些特殊的规则才能使用 ；

- CommonJS模块输出的是一个值的拷贝，ES6 模块输出的是值的引用；

  ```js
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
  }
  module.exports = {
    counter: counter,
    incCounter: incCounter,
  };
  //commonjs
  var mod = require('./lib');
  console.log(mod.counter);  // 3
  mod.incCounter();
  console.log(mod.counter); // 3
  //ES6
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```

  

- CommonJS 模块是运行时加载，Module被加载的时候执行，加载后缓存（只加载一次，第二次就直接用放到内存中的结果，不重复加载了，第一次加载的时候会执行）。ES6 模块是编译时输出接口,使得对JS的模块进行静态分析成为了可能

- `this`关键词，在ES6模块顶层，`this`指向`undefined`；而CommonJS模块的顶层的`this`指向当前模块

## 异步操作

**背景:js语言执行环境是单线程**

JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，**单个脚本**只能在一个线程上运行（称为主线程），其他线程都是在后台配合。

```
JS中的异步操作：
1、定时器都是异步操作
2、事件绑定都是异步操作
3、AJAX中一般我们都采取异步操作（也可以同步）
4、回调函数可以理解为异步（不是严谨的异步操作）
剩下的都是同步处理
```

### 1:回调函数

一个函数作为参数传递到另一个函数中

```js
function f1(callback){
	setTimeout(function(){
	callback()//f1的任务
	},1000)
}
f1(f2);
```

优缺点:简单,容易部署,但不利于代码的阅读和维护,各部分之间高度耦合

**注意:回调并不一定是异步**

### 2.事件监听

异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生

监听函数:on,bind,listen,addEventListener

监听方法:onclick...

### 3发布/订阅

事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”[发布/订阅模式](https://en.wikipedia.org/wiki/Publish-subscribe_pattern)”（publish-subscribe pattern），又称“[观察者模式](https://en.wikipedia.org/wiki/Observer_pattern)”（observer pattern）。

首先，`f2`向信号中心`jQuery`订阅`done`信号。

```
jQuery.subscribe('done', f2);
```

然后，`f1`进行如下改写。

```
function f1() {
  setTimeout(function () {
    // ...
    jQuery.publish('done');
  }, 1000);
}
```

上面代码中，`jQuery.publish('done')`的意思是，`f1`执行完成后，向信号中心`jQuery`发布`done`信号，从而引发`f2`的执行。

`f2`完成执行后，可以取消订阅（unsubscribe）。

```
jQuery.unsubscribe('done', f2);	
```

### 4.promise

- **名称**
   译为“承诺”，这也就表达了将来会执行的操作，代表异步操作；

- **状态**
   一共有三种状态，分别为`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。

- **特点**
   (1)只有异步操作可以决定当前处于的状态，并且任何其他操作无法改变这个状态；
   (2)一旦状态改变，就不会在变。状态改变的过程只可能是：从`pending`变为`fulfilled`和从`pending`变为`rejected`。如果状态发生上述变化后，此时状态就不会在改变了，这时就称为`resolved`（已定型）

- **基本用法**

  Promise 对象是由关键字 new 及其构造函数来创建的。

  ```js
  const promise = new Promise((resolve, reject) => {
      // do something here ...
      if (success) {
          resolve(value); // fulfilled
      } else {
          reject(error); // rejected
      }
  });
  ```

  该构造函数接收两个函数作为参数，分别是`resolve`和`reject`。
   当异步操作执行成功后，会将异步操作结果作为参数传入`resolve`函数并执行，此时 `Promise`对象状态从`pending`变为`fulfilled`；
   失败则会将异步操作的错误作为参数传入`reject`函数并执行，此时 `Promise`对象状态从`pending`变为`rejected`；

```js
let a = new Promise(function(resolve,reject){
    if(1){
        console.log(4)
        resolve(1)
    }
})
setTimeout(function(){
    console.log(5)
},1000)
console.log(2)
a.then(function(calue){
    console.log(calue)
})
console.log(3)

//42315
```

```js
var a = new Promise((resolve,reject)=>{
    reject(1)
})
a.catch((i)=>{
    console.log(i)
    return new Promise((resolve,reject)=>{
        reject(2)
    })
}).then((i)=>{
    console.log(i)
})
// 1
//返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
```

- 返回新的promise，那么下一级.then()会在新的promise状态改变之后执行
- 没有return，相当于return Promise.resolve(undefined);
- return非Promise的数据data，相当于return Promise.resolve(data);

### 5.async/await

定义：使异步函数以同步函数的形式书写(Generator函数语法糖)

原理：将`Generator函数`和自动执行器`spawn`包装在一个函数里

形式：将`Generator函数`的`*`替换成`async`，将`yield`替换成`await`

声明

- 函数：`async function Func() {}`
- 函数表达式：`const func = async function() {}`
- 箭头函数：`const func = async() => {}`
- 对象方法：`const obj = { async func() {} }`
- 类方法：`class Cla { async Func() {} }`

**async函数的返回值总是一个Promise**

无论async函数有无await操作，其总是返回一个Promise。因此，其后面可以直接调用then方法，函数内部return返回的值，会成为then回调函数的参数。函数内部抛出的错误，会被then的第二个函数或catch方法捕获到

1. 没有显式return，相当于return Promise.resolve(undefined);
2. return非Promise的数据data，相当于return Promise.resolve(data);
3. return Promise, 会得到Promise对象本身

 **await操作符的值**

```
[rv] = await expression（expression可以是任何值，通常是一个promise）
```

expression是Promise，rv等于Promise兑现的值，若Promise被拒绝，则抛出异常，由catch捕获
expression是非Promise，会立即被转换为resolve的Promise，rv等于expression

```js
let a =async function(){
    let b = await l();
    console.log(b)
    let c = await h();
    console.log(c)
    return 2
}
function l(){
    console.log(1)
    return 3
}
function h(){
    console.log(5)
    return 6
}
a().then(function(v){
    console.log(v)
})
    console.log(a)//[λ: a]
//1,[λ: a],3,5,6,2
```

**tips**

返回的Promise对象必须等到内部所有`await命令Promise对象`执行完才会发生状态改变，除非遇到`return语句`或`抛出错误`

任何一个`await命令Promise对象`变为`rejected状态`，整个`Async函数`都会中断执行

希望即使前一个异步操作失败也不要中断后面的异步操作

- 将`await命令Promise对象`放到`try-catch`中
- `await命令Promise对象`跟一个`catch()`

`await命令Promise对象`可能变为`rejected状态`，最好把其放到`try-catch`中

多个`await命令Promise对象`若不存在继发关系，最好让它们同时触发

```js
//变量分别接收Promise
let fooPromise = getFoo();
let barPromise = getBar();
let foo = await fooPromise();
let bar = await barPromise();
//使用Promise.all
let [foo,bar] = await Promise.all([getFoo(),getBar()]);


```

`await命令`只能用在`Async函数`之中，否则会报错

数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和`Promise.all()`代替

可保留运行堆栈，函数上下文随着`Async函数`的执行而存在，执行完成就消失

# 原生

## MutationObserver

https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver

当父元素中的元素有删减，会调用该函数。

eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled

tip: 添加合理的判断条件，否则会执行死循环